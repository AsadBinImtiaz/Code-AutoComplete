{"input": "Class to define an API Schema from an inline string. The schema can be provided directly as a string in either JSON or YAML format.", "output": "export class InlineApiSchema extends ApiSchema {\n  constructor(private readonly schema: string) {\n    super(undefined, schema);\n  }\n\n  /**\n   * @internal This is an internal core function and should not be called directly.\n   */\n  public _render(): CfnAgent.APISchemaProperty {\n    return {\n      payload: this.schema,\n    };\n  }\n}", "language": "typescript"}
{"input": "Access control configuration for ElastiCache users.", "output": "class AccessControl {\n  /**\n   * Create access control from an access string.\n   *\n   * @param accessString The access string defining user permissions.\n   */\n  public static fromAccessString(accessString: string): AccessControl {\n    return new AccessControlString(accessString);\n  }\n\n  /**\n   * The access string that defines user's permissions.\n   */\n  public abstract readonly accessString: string;\n}\n\n/**\n * Access control implementation using a raw access string.\n */\nclass AccessControlString extends AccessControl {\n  /**\n   * The access string that defines user's permissions.\n   */\n  public readonly accessString: string;\n\n  constructor(accessString: string) {\n    super();\n    this.accessString = accessString;\n  }\n}", "language": "typescript"}
{"input": "Base class for different types of Spark Jobs.", "output": "class SparkJob extends Job {\n  public readonly role: iam.IRole;\n  public readonly grantPrincipal: iam.IPrincipal;\n\n  /**\n   * The Spark UI logs location if Spark UI monitoring and debugging is enabled.\n   *\n   * @see https://docs.aws.amazon.com/glue/latest/dg/monitor-spark-ui-jobs.html\n   * @see https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html\n   */\n  public readonly sparkUILoggingLocation?: SparkUILoggingLocation;\n\n  constructor(scope: constructs.Construct, id: string, props: SparkJobProps) {\n    super(scope, id, {\n      physicalName: props.jobName,\n    });\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    this.role = props.role;\n    this.grantPrincipal = this.role;\n\n    this.sparkUILoggingLocation = props.sparkUI ? this.setupSparkUILoggingLocation(props.sparkUI) : undefined;\n  }\n\n  protected nonExecutableCommonArguments(props: SparkJobProps): {[key: string]: string} {\n    // Enable CloudWatch metrics and continuous logging by default as a best practice\n    const continuousLoggingArgs = this.setupContinuousLogging(this.role, props.continuousLogging);\n\n    // Conditionally include metrics arguments (default to enabled for backward compatibility)\n    const profilingMetricsArgs = (props.enableMetrics ?? true) ? { '--enable-metrics': '' } : {};\n    const observabilityMetricsArgs = (props.enableObservabilityMetrics ?? true) ? { '--enable-observability-metrics': 'true' } : {};\n\n    // Set spark ui args, if spark ui logging had been setup\n    const sparkUIArgs = this.sparkUILoggingLocation ? ({\n      '--enable-spark-ui': 'true',\n      '--spark-event-logs-path': this.sparkUILoggingLocation.bucket.s3UrlForObject(this.sparkUILoggingLocation.prefix).replace(/\\/?$/, '/'), // path will always end with a slash\n    }): {};\n\n    return {\n      ...continuousLoggingArgs,\n      ...profilingMetricsArgs,\n      ...observabilityMetricsArgs,\n      ...sparkUIArgs,\n      ...this.checkNoReservedArgs(props.defaultArguments),\n    };\n  }\n\n  /**\n   * Set the arguments for extra {@link Code}-related properties\n   */\n  protected setupExtraCodeArguments(args: { [key: string]: string }, props: SparkExtraCodeProps) {\n    if (props.extraJars && props.extraJars.length > 0) {\n      args['--extra-jars'] = props.extraJars.map(code => this.codeS3ObjectUrl(code)).join(',');\n    }\n    if (props.extraJarsFirst) {\n      args['--user-jars-first'] = 'true';\n    }\n    if (props.extraPythonFiles && props.extraPythonFiles.length > 0) {\n      args['--extra-py-files'] = props.extraPythonFiles.map(code => this.codeS3ObjectUrl(code)).join(',');\n    }\n    if (props.extraFiles && props.extraFiles.length > 0) {\n      args['--extra-files'] = props.extraFiles.map(code => this.codeS3ObjectUrl(code)).join(',');\n    }\n  }\n\n  private setupSparkUILoggingLocation(props: SparkUIProps): SparkUILoggingLocation {\n    validateSparkUiPrefix(props.prefix);\n    const bucket = props.bucket ?? new s3.Bucket(this, 'SparkUIBucket', { enforceSSL: true, encryption: s3.BucketEncryption.S3_MANAGED });\n    bucket.grantReadWrite(this, cleanSparkUiPrefixForGrant(props.prefix));\n    return {\n      prefix: props.prefix,\n      bucket,\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates CloudFormation, CDK Pipelines, CodePipeline resources", "output": "export class PipelineStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const pipeline = new pipelines.CodePipeline(this, 'Pipeline', {\n      synth: new pipelines.ShellStep('Synth', {\n        input: pipelines.CodePipelineSource.connection('org/reponame', 'branchname', {\n          connectionArn: 'arn:aws:codestar-connections:us-east-1:123456789012:connection/abcdefg',\n        }),\n        commands: [\n          'npm ci',\n          'npm run build',\n          'npx cdk synth',\n        ],\n      }),\n      selfMutation: true,\n    });\n\n    const wave = pipeline.addWave('DeployWave');\n\n    wave.addStage(new AppStacks(this, 'AppsUS', {\n      env: { account: props?.env?.account, region: 'us-east-1' }\n    }));\n    wave.addStage(new AppStacks(this, 'AppsEU', {\n      env: { account: props?.env?.account, region: 'eu-west-1' }\n    }));\n\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates S3, Lambda, IAM resources", "output": "class RekognitionVideoProcessorStack(Stack):\n\n    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:\n        super().__init__(scope, construct_id, **kwargs)\n\n         # S3 bucket to store videos\n        video_bucket = s3.Bucket(\n            self,\n            \"S3Bucket\",\n            removal_policy=RemovalPolicy.DESTROY,\n        )\n\n        # SNS\n        rekognition_sns_topic = sns.Topic(\n            self,\n            \"RekognitionSnsTopic\",\n            display_name=\"Rekognition Job Completion SNS Topic\",\n        )\n\n        rekognition_role = iam.Role(\n            self,\n            \"RekognitionRole\",\n            assumed_by=iam.ServicePrincipal(\"rekognition.amazonaws.com\"),\n            managed_policies=[\n                iam.ManagedPolicy.from_aws_managed_policy_name(\"AmazonSNSFullAccess\"),\n            ],\n        )\n\n        # Define IAM permissions needed\n        s3_lambda_policy = iam.PolicyStatement(\n            actions=[\"s3:GetObject\"],\n            resources=[video_bucket.bucket_arn, video_bucket.bucket_arn + \"/*\"],\n            effect=iam.Effect.ALLOW,\n        )\n        rekognition_lambda_policy = iam.PolicyStatement(\n            actions=[\"rekognition:*\"],\n            resources=[\"*\"],\n            effect=iam.Effect.ALLOW,\n        )\n        pass_role_lambda_policy =iam.PolicyStatement(\n                actions=[\"iam:PassRole\"],\n                resources=[\n                    rekognition_role.role_arn\n                ],\n            )\n\n        # Lambda which detects when a video has been uploaded to the S3 bucket and starts the video processing with Rekognition\n        start_processing_lambda_function = lambda_.Function(\n            self,\n            \"LambdaFunction\",\n            function_name=\"start-processing-rekognition-demo-lambda\",\n            runtime=lambda_.Runtime.PYTHON_3_10,\n            handler=\"index.lambda_handler\",\n            code=lambda_.Code.from_asset(\"lambdas/start_processing\"),\n            environment={\n                \"SNS_TOPIC_ARN\": rekognition_sns_topic.topic_arn,\n                \"SNS_ROLE_ARN\": rekognition_role.role_arn,\n            },\n        )\n\n        # Lambda which detects when a video has been processed by reckognition. It stracts the data of each celebrity identified\n        process_video_lambda = lambda_.Function(\n            self,\n            \"RekognitionLambda\",\n            function_name=\"process-video-rekognition-demo-lambda\",\n            runtime=lambda_.Runtime.PYTHON_3_10,\n            handler=\"index.lambda_handler\",\n            code=lambda_.Code.from_asset(\"lambdas/process_video\"),\n        )\n\n        # Grant permissions to the lambdas defined\n        start_processing_lambda_function.add_to_role_policy(s3_lambda_policy)\n        start_processing_lambda_function.add_to_role_policy(rekognition_lambda_policy)\n        start_processing_lambda_function.add_to_role_policy(pass_role_lambda_policy)\n\n        process_video_lambda.add_to_role_policy(rekognition_lambda_policy)\n\n        rekognition_sns_topic.grant_publish(process_video_lambda)\n        rekognition_sns_topic.add_subscription(sns_subs.LambdaSubscription(process_video_lambda))\n\n        # Automatically trigger lambda when new image is uploaded to S3\n        start_processing_lambda_function.add_event_source(\n            aws_lambda_event_sources.S3EventSource(\n                video_bucket, events=[s3.EventType.OBJECT_CREATED]\n            )\n        )", "language": "python"}
{"input": "CDK helper function visit", "output": "const visit = (node: IConstruct) => {\n      if (minimatch(node.node[this.field], this.pattern)) {\n        result.push(node);\n      }\n      for (const child of node.node.children) {\n        visit(child);\n      }\n    }", "language": "typescript"}
{"input": "CDK Stack that creates S3, Lambda, AppSync, EventBridge resources", "output": "class EventApiChannelNamespaceStack extends cdk.Stack {\n  public readonly eventApi: appsync.EventApi;\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    const authorizer = new lambda.Function(this, 'AuthorizerFunction', {\n      runtime: STANDARD_NODEJS_RUNTIME,\n      code: lambda.Code.fromInline(`\n            exports.handler = async (event) => {\n              console.log(\"Authorization event:\", JSON.stringify(event));\n\n              const isAuthorized = true;\n              if (isAuthorized) {\n                return {\n                  isAuthorized: true,\n                  resolverContext: {\n                    userId: 'user-id-example'\n                  }\n                };\n              } else {\n                return {\n                  isAuthorized: false\n                };\n              }\n            };\n          `),\n      handler: 'index.handler',\n    });\n\n    const lambdaProvider: appsync.AppSyncAuthProvider = {\n      authorizationType: appsync.AppSyncAuthorizationType.LAMBDA,\n      lambdaAuthorizerConfig: {\n        handler: authorizer,\n      },\n    };\n\n    const iamProvider: appsync.AppSyncAuthProvider = {\n      authorizationType: appsync.AppSyncAuthorizationType.IAM,\n    };\n\n    const api = new appsync.EventApi(this, 'EventApi', {\n      apiName: 'api-channel-namespace-test',\n      ownerContact: 'test-owner-contact',\n      authorizationConfig: {\n        authProviders: [\n          lambdaProvider,\n          iamProvider,\n        ],\n      },\n      logConfig: {\n        fieldLogLevel: appsync.AppSyncFieldLogLevel.ERROR,\n      },\n    });\n    this.eventApi = api;\n\n    new appsync.ChannelNamespace(this, 'ChannelNamespace', {\n      api,\n      authorizationConfig: {\n        publishAuthModeTypes: [\n          appsync.AppSyncAuthorizationType.LAMBDA,\n        ],\n        subscribeAuthModeTypes: [\n          appsync.AppSyncAuthorizationType.LAMBDA,\n        ],\n      },\n      code: appsync.Code.fromAsset(path.join(\n        __dirname,\n        'integ-assets',\n        'appsync-js-channel-namespace-handler.js',\n      )),\n    });\n\n    api.addChannelNamespace('AnotherChannelNamespace', {\n      code: appsync.Code.fromInline(`\n            export function onPublish(ctx) {\n              return ctx.events.filter((event) => event.payload.odds > 0)\n            }\n          `),\n    });\n  }\n}", "language": "typescript"}
{"input": "Tool Schema from a local asset. The asset is uploaded to an S3 staging bucket, then moved to its final location by CloudFormation during deployment.", "output": "export class AssetToolSchema extends ToolSchema {\n  private asset?: s3_assets.Asset;\n\n  constructor(private readonly path: string, private readonly options: s3_assets.AssetOptions = {}) {\n    super();\n  }\n\n  /**\n   * Binds this tool schema to a construct scope.\n   * This method initializes the S3 asset if it hasn't been initialized yet.\n   * Must be called before rendering the schema as CFN properties.\n   *\n   * @param scope - The construct scope to bind to\n   */\n  public bind(scope: Construct): void {\n    // If the same AssetToolSchema is used multiple times, retain only the first instantiation\n    if (!this.asset) {\n      this.asset = new s3_assets.Asset(scope, 'Schema', {\n        path: this.path,\n        ...this.options,\n      });\n      // Note: Permissions will be granted by the Gateway target construct when adding the target\n    }\n  }\n\n  /**\n   * Format as CFN properties\n   * @internal This is an internal core function and should not be called directly.\n   */\n  public _render(): any {\n    if (!this.asset) {\n      throw new ToolSchemaError(\n        'ToolSchema must be bound to a scope before rendering. Call bind() first.',\n        'Asset not initialized',\n      );\n    }\n\n    return {\n      s3: {\n        uri: `s3://${this.asset.s3BucketName}/${this.asset.s3ObjectKey}`,\n      },\n    };\n  }\n\n  public grantPermissionsToRole(role: IRole): void {\n    if (!this.asset) {\n      throw new ToolSchemaError(\n        'ToolSchema must be bound to a scope before rendering. Call bind() first.',\n        'Asset not initialized',\n      );\n    }\n    this.asset.grantRead(role);\n  }\n}\n\n// ------------------------------------------------------\n/**\n * Class to define a Tool Schema from an inline string.\n * The schema can be provided directly as a string in either JSON or YAML format.\n */\nexport class InlineToolSchema extends ToolSchema {\n  constructor(private readonly schema: ToolDefinition[]) {\n    super(undefined, undefined, schema);\n  }\n\n  /**\n   * @internal This is an internal core function and should not be called directly.\n   */\n  public _render(): any {\n    return {\n      inlinePayload: this.schema,\n    };\n  }\n\n  public bind(scope: Construct): void {\n    if (scope) {\n    }\n    // No-op\n  }\n\n  public grantPermissionsToRole(_role: IRole): void {\n    // No-op - InlineToolSchema doesn't need permissions\n  }", "language": "typescript"}
{"input": "CDK class SelfManagedKafkaEventSource for AWS resource management", "output": "export class SelfManagedKafkaEventSource extends StreamEventSource {\n  // This is to work around JSII inheritance problems\n  private innerProps: SelfManagedKafkaEventSourceProps;\n\n  constructor(props: SelfManagedKafkaEventSourceProps) {\n    super(props);\n    if (props.vpc) {\n      if (!props.securityGroup) {\n        throw new UnscopedValidationError('securityGroup must be set when providing vpc');\n      }\n      if (!props.vpcSubnets) {\n        throw new UnscopedValidationError('vpcSubnets must be set when providing vpc');\n      }\n    } else if (!props.secret) {\n      throw new UnscopedValidationError('secret must be set if Kafka brokers accessed over Internet');\n    }\n\n    if (props.startingPosition === lambda.StartingPosition.AT_TIMESTAMP && !props.startingPositionTimestamp) {\n      throw new UnscopedValidationError('startingPositionTimestamp must be provided when startingPosition is AT_TIMESTAMP');\n    }\n\n    if (props.startingPosition !== lambda.StartingPosition.AT_TIMESTAMP && props.startingPositionTimestamp) {\n      throw new UnscopedValidationError('startingPositionTimestamp can only be used when startingPosition is AT_TIMESTAMP');\n    }\n\n    this.innerProps = props;\n  }\n\n  public bind(target: lambda.IFunction) {\n    if (!(Construct.isConstruct(target))) { throw new ValidationError('Function is not a construct. Unexpected error.', target); }\n    target.addEventSourceMapping(\n      this.mappingId(target),\n      this.enrichMappingOptions({\n        filters: this.innerProps.filters,\n        filterEncryption: this.innerProps.filterEncryption,\n        kafkaBootstrapServers: this.innerProps.bootstrapServers,\n        kafkaTopic: this.innerProps.topic,\n        kafkaConsumerGroupId: this.innerProps.consumerGroupId,\n        startingPosition: this.innerProps.startingPosition,\n        startingPositionTimestamp: this.innerProps.startingPositionTimestamp,\n        sourceAccessConfigurations: this.sourceAccessConfigurations(),\n        onFailure: this.innerProps.onFailure,\n        supportS3OnFailureDestination: true,\n        provisionedPollerConfig: this.innerProps.provisionedPollerConfig,\n        schemaRegistryConfig: this.innerProps.schemaRegistryConfig,\n        bisectBatchOnError: this.innerProps.bisectBatchOnError,\n        retryAttempts: this.innerProps.retryAttempts,\n        reportBatchItemFailures: this.innerProps.reportBatchItemFailures,\n        maxRecordAge: this.innerProps.maxRecordAge,\n      }),\n    );\n\n    if (this.innerProps.secret !== undefined) {\n      this.innerProps.secret.grantRead(target);\n    }\n  }\n\n  private mappingId(target: lambda.IFunction) {\n    const idHash = md5hash(JSON.stringify(Stack.of(target).resolve(this.innerProps.bootstrapServers)));\n    return `KafkaEventSource:${idHash}:${this.innerProps.topic}`;\n  }\n\n  private sourceAccessConfigurations() {\n    let authType;\n    switch (this.innerProps.authenticationMethod) {\n      case AuthenticationMethod.BASIC_AUTH:\n        authType = lambda.SourceAccessConfigurationType.BASIC_AUTH;\n        break;\n      case AuthenticationMethod.CLIENT_CERTIFICATE_TLS_AUTH:\n        authType = lambda.SourceAccessConfigurationType.CLIENT_CERTIFICATE_TLS_AUTH;\n        break;\n      case AuthenticationMethod.SASL_SCRAM_256_AUTH:\n        authType = lambda.SourceAccessConfigurationType.SASL_SCRAM_256_AUTH;\n        break;\n      case AuthenticationMethod.SASL_SCRAM_512_AUTH:\n      default:\n        authType = lambda.SourceAccessConfigurationType.SASL_SCRAM_512_AUTH;\n        break;\n    }\n\n    const sourceAccessConfigurations = [];\n    if (this.innerProps.secret !== undefined) {\n      sourceAccessConfigurations.push({ type: authType, uri: this.innerProps.secret.secretArn });\n    }\n\n    if (this.innerProps.rootCACertificate !== undefined) {\n      sourceAccessConfigurations.push({\n        type: lambda.SourceAccessConfigurationType.SERVER_ROOT_CA_CERTIFICATE,\n        uri: this.innerProps.rootCACertificate.secretArn,\n      });\n    }\n\n    if (this.innerProps.vpcSubnets !== undefined && this.innerProps.securityGroup !== undefined) {\n      sourceAccessConfigurations.push({\n        type: lambda.SourceAccessConfigurationType.VPC_SECURITY_GROUP,\n        uri: this.innerProps.securityGroup.securityGroupId,\n      },\n      );\n      this.innerProps.vpc?.selectSubnets(this.innerProps.vpcSubnets).subnetIds.forEach((id) => {\n        sourceAccessConfigurations.push({ type: lambda.SourceAccessConfigurationType.VPC_SUBNET, uri: id });\n      });\n    }\n\n    return sourceAccessConfigurations.length === 0\n      ? undefined\n      : sourceAccessConfigurations;\n  }\n}", "language": "typescript"}
{"input": "Snapshot test for table bucket with default parameters", "output": "class DefaultTestStack extends core.Stack {\n  public readonly tableBucket: s3tables.TableBucket;\n\n  constructor(scope: Construct, id: string, props?: core.StackProps) {\n    super(scope, id, props);\n\n    this.tableBucket = new s3tables.TableBucket(this, 'DefaultBucket', {\n      tableBucketName: 'default-test-bucket',\n      // we don't want to leave trash in the account after running the deployment of this\n      removalPolicy: core.RemovalPolicy.DESTROY,\n    });\n  }\n}\n\n/**\n * Snapshot test for table bucket with optional parameters\n */\nclass UnreferencedFileRemovalTestStack extends core.Stack {\n  public readonly tableBucket: s3tables.TableBucket;\n\n  constructor(scope: Construct, id: string, props?: core.StackProps) {\n    super(scope, id, props);\n\n    this.tableBucket = new s3tables.TableBucket(this, 'DefaultBucket', {\n      tableBucketName: 'unreferenced-file-removal-test-bucket',\n      unreferencedFileRemoval: {\n        noncurrentDays: 20,\n        status: s3tables.UnreferencedFileRemovalStatus.DISABLED,\n        unreferencedDays: 20,\n      },\n      // we don't want to leave trash in the account after running the deployment of this\n      removalPolicy: core.RemovalPolicy.DESTROY,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class GitHubSourceCredentials for AWS resource management", "output": "export class GitHubSourceCredentials extends Resource {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-codebuild.GitHubSourceCredentials';\n\n  constructor(scope: Construct, id: string, props: GitHubSourceCredentialsProps) {\n    super(scope, id);\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    new CfnSourceCredential(this, 'Resource', {\n      serverType: 'GITHUB',\n      authType: 'PERSONAL_ACCESS_TOKEN',\n      token: props.accessToken.unsafeUnwrap(), // Safe usage\n    });\n  }\n}", "language": "typescript"}
{"input": "Used for HTTP cache-control header, which influences downstream caches. @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata", "output": "export class CacheControl {\n  /**\n   * Sets 'must-revalidate'.\n   */\n  public static mustRevalidate() { return new CacheControl('must-revalidate'); }\n\n  /**\n   * Sets 'no-cache'.\n   */\n  public static noCache() { return new CacheControl('no-cache'); }\n\n  /**\n   * Sets 'no-transform'.\n   */\n  public static noTransform() { return new CacheControl('no-transform'); }\n\n  /**\n   * Sets 'no-store'.\n   */\n  public static noStore() { return new CacheControl('no-store'); }\n\n  /**\n   * Sets 'must-understand'.\n   */\n  public static mustUnderstand() { return new CacheControl('must-understand'); }\n\n  /**\n   * Sets 'public'.\n   */\n  public static setPublic() { return new CacheControl('public'); }\n\n  /**\n   * Sets 'private'.\n   */\n  public static setPrivate() { return new CacheControl('private'); }\n\n  /**\n   * Sets 'immutable'.\n   */\n  public static immutable() { return new CacheControl('immutable'); }\n\n  /**\n   * Sets 'proxy-revalidate'.\n   */\n  public static proxyRevalidate() { return new CacheControl('proxy-revalidate'); }\n\n  /**\n   * Sets 'max-age=<duration-in-seconds>'.\n   */\n  public static maxAge(t: cdk.Duration) { return new CacheControl(`max-age=${t.toSeconds()}`); }\n\n  /**\n   * Sets 's-maxage=<duration-in-seconds>'.\n   */\n  public static sMaxAge(t: cdk.Duration) { return new CacheControl(`s-maxage=${t.toSeconds()}`); }\n\n  /**\n   * Sets 'stale-while-revalidate=<duration-in-seconds>'.\n   */\n  public static staleWhileRevalidate(t: cdk.Duration) { return new CacheControl(`stale-while-revalidate=${t.toSeconds()}`); }\n\n  /**\n   * Sets 'stale-if-error=<duration-in-seconds>'.\n   */\n  public static staleIfError(t: cdk.Duration) { return new CacheControl(`stale-if-error=${t.toSeconds()}`); }\n\n  /**\n   * Constructs a custom cache control key from the literal value.\n   */\n  public static fromString(s: string) { return new CacheControl(s); }\n\n  private constructor(\n    /**\n     * The raw cache control setting.\n     */\n    public readonly value: any,\n  ) { }\n}", "language": "typescript"}
{"input": "CDK helper function for S3, ECR operations", "output": "def __init__(self, scope: Construct, id: str, **kwargs, ) -> None:\n        super().__init__(scope, id,  **kwargs )\n        # Creates two ecr repositories that will host the docker images for the color teller gateway app and color teller app\n        FrontendRepository = ecr.Repository(self, \"FrontendRepository\", repository_name=\"frontend\")\n        BackendDataRepository = ecr.Repository(self, \"BackendDataRepository\", repository_name=\"backend_data\")\n\n        # The docker images were built on a M1 Macbook Pro, you may have to rebuild your images\n        frontendAsset = DockerImageAsset(self, \"frontendAsset\",\n            directory=\"./services/frontend\",\n            build_args={\n                \"SERVICE_B_URL_BUILD_ARG\": \"data.scapp.local\" # This argument will be passed to the dockerfile and is the URL that the frontend app will use to call the backend\n            },\n            \n            platform=Platform.LINUX_AMD64\n        )\n        dataAsset = DockerImageAsset(self, \"dataAsset\",\n            directory=\"./services/data\",\n\n        )\n        # Deploying images to ECR\n        ecrdeploy.ECRDeployment(self, \"DeployFrontendImage\",\n            src=ecrdeploy.DockerImageName(frontendAsset.image_uri),\n            dest=ecrdeploy.DockerImageName(f\"{Aws.ACCOUNT_ID}.dkr.ecr.{Aws.REGION}.amazonaws.com/frontend:latest\")\n        )\n\n       \n\n        ecrdeploy.ECRDeployment(self, \"DeployBackendImage\",\n            src=ecrdeploy.DockerImageName(dataAsset.image_uri),\n            dest=ecrdeploy.DockerImageName(f\"{Aws.ACCOUNT_ID}.dkr.ecr.{Aws.REGION}.amazonaws.com/backend_data:latest\")\n        )\n\n        # Exporting values to be used in other stacks\n        self.frontend_docker_asset = frontendAsset\n        self.backend_data_docker_asset = dataAsset", "language": "python"}
{"input": "CDK class GrantTestBase for AWS resource management", "output": "class GrantTestBase extends core.Stack {\n  public readonly table: s3tables.Table;\n  public readonly tableBucket: s3tables.TableBucket;\n  public readonly namespace: s3tables.Namespace;\n  abstract readonly actions: string[];\n\n  constructor(scope: Construct, id: string, props?: core.StackProps) {\n    super(scope, id, props);\n    this.tableBucket = new s3tables.TableBucket(this, 'TableBucket', {\n      tableBucketName: `${id}-bucket`,\n      removalPolicy: core.RemovalPolicy.DESTROY,\n    });\n    this.namespace = new s3tables.Namespace(this, 'Namespace', {\n      tableBucket: this.tableBucket,\n      namespaceName: 'test_namespace',\n    });\n    this.table = new s3tables.Table(this, 'Table', {\n      tableName: this.getTableName(),\n      namespace: this.namespace,\n      openTableFormat: s3tables.OpenTableFormat.ICEBERG,\n      removalPolicy: core.RemovalPolicy.DESTROY,\n      withoutMetadata: true,\n    });\n    this.grantAccess();\n  }\n  abstract grantAccess(): void;\n  abstract getTableName(): string;\n}", "language": "typescript"}
{"input": "Class to validate that inputs match requirements.", "output": "export class InputValidator {\n  /**\n   * Validates length is between allowed min and max lengths.\n   */\n  public static validateLength(resourceName: string, inputName: string, minLength: number, maxLength: number, inputString?: string): void {\n    if (!cdk.Token.isUnresolved(inputString) && inputString !== undefined && (inputString.length < minLength || inputString.length > maxLength)) {\n      throw new Error(`Invalid ${inputName} for resource ${resourceName}, must have length between ${minLength} and ${maxLength}, got: '${this.truncateString(inputString, 100)}'`);\n    }\n  }\n\n  /**\n   * Validates a regex.\n   */\n  public static validateRegex(resourceName: string, inputName: string, regex: RegExp, inputString?: string): void {\n    if (!cdk.Token.isUnresolved(inputString) && inputString !== undefined && !regex.test(inputString)) {\n      throw new Error(`Invalid ${inputName} for resource ${resourceName}, must match regex pattern ${regex}, got: '${this.truncateString(inputString, 100)}'`);\n    }\n  }\n\n  private static truncateString(string: string, maxLength: number): string {\n    if (string.length > maxLength) {\n      return string.substring(0, maxLength) + '[truncated]';\n    }\n    return string;\n  }\n}", "language": "typescript"}
{"input": "CDK class EnumsUpdater for AWS resource management", "output": "export class EnumsUpdater extends MetadataUpdater {\n  constructor(dir: string) {\n    super(dir);\n  }\n\n  /**\n   * Parse the repository for any enum type values and generate a JSON blueprint.\n   */\n  public execute() {\n    const enumBlueprint: Record<string, (string | number)[]> = {};\n    const moduleEnumBlueprint: Record<string, Record<string, (string | number)[]>> = {};\n\n    this.project.getSourceFiles().forEach((sourceFile) => {\n      const sourceFileName: string = sourceFile.getFilePath().split(\"/aws-cdk/\")[1]\n      let fileBlueprint: Record<string, (string | number)[]> = {};\n      sourceFile.forEachChild((node) => {\n        if (node.getKindName() === \"EnumDeclaration\") {\n          const enumDeclaration = node.asKindOrThrow(SyntaxKind.EnumDeclaration);\n          const enumName = enumDeclaration.getName();\n          // Directly access the values of the enum members\n          const enumValues = enumDeclaration.getMembers()\n            .map((member) => member.getValue()) // Access the enum value directly\n            .filter((value) => value !== undefined); // Filter out undefined values\n\n          // Add to the blueprint\n          enumBlueprint[enumName] = enumValues;\n          fileBlueprint[enumName] = enumValues;\n        }\n      });\n      if (Object.values(fileBlueprint).length > 0) {\n        moduleEnumBlueprint[sourceFileName] = fileBlueprint;\n      }\n    });\n\n    // Generate the file content\n    const content = this.generateFileContent(enumBlueprint);\n    const outputPath = path.resolve(\n      __dirname,\n      \"../../../../packages/aws-cdk-lib/core/lib/analytics-data-source/enums.ts\"\n    );\n    const moduleOutputPath = path.resolve(\n      __dirname,\n      \"../../../../packages/aws-cdk-lib/core/lib/analytics-data-source/enums/module-enums.json\"\n    );\n\n    // Write the generated file\n    fs.writeFileSync(outputPath, content);\n    console.log(`Metadata file written to: ${outputPath}`);\n    this.writeFileContent(moduleOutputPath, moduleEnumBlueprint);\n    console.log(`Metadata file written to: ${moduleOutputPath}`);\n  }\n\n  /**\n   * Generate the file content for the enum metadats.\n   */\n  private generateFileContent(enums: Record<string, (string | number)[]> = {}): string {\n    const template = `/* eslint-disable quotes */\n/* eslint-disable @stylistic/quote-props */\n/* eslint-disable @stylistic/comma-dangle */\n/* eslint-disable @cdklabs/no-literal-partition */\n/*\n * Do not edit this file manually. To prevent misconfiguration, this file\n * should only be modified by an automated GitHub workflow, that ensures\n * that the ENUMs present in this list\n *\n */\n\nexport const AWS_CDK_ENUMS: { [key: string]: any } = $ENUMS;\n`;\n\n    // Sort the keys of the enums object\n    const sortedEnums = Object.keys(enums).sort().reduce<Record<string, (string | number)[]>>((acc, key) => {\n      acc[key] = enums[key];\n      return acc;\n    }, {});\n    const jsonContent = JSON.stringify(sortedEnums, null, 2);\n\n    // Replace the placeholder with the JSON object\n    return template.replace(\"$ENUMS\", jsonContent);\n  }\n}", "language": "typescript"}
{"input": "CDK class YarnNohoistBundledDependencies for AWS resource management", "output": "export class YarnNohoistBundledDependencies extends ValidationRule {\n  public readonly name = 'yarn/nohoist-bundled-dependencies';\n\n  public validate(pkg: PackageJson) {\n    const bundled: string[] = pkg.json.bundleDependencies || pkg.json.bundledDependencies || [];\n    if (bundled.length === 0) { return; }\n\n    const repoPackageJson = path.resolve(monoRepoRoot(), 'package.json');\n\n    const nohoist: string[] = require(repoPackageJson).workspaces.nohoist; // eslint-disable-line @typescript-eslint/no-require-imports\n\n    const missing = new Array<string>();\n    for (const dep of bundled) {\n      for (const entry of [`${pkg.packageName}/${dep}`, `${pkg.packageName}/${dep}/**`]) {\n        if (nohoist.indexOf(entry) >= 0) { continue; }\n        missing.push(entry);\n      }\n    }\n\n    if (missing.length > 0) {\n      pkg.report({\n        ruleName: this.name,\n        message: `Repository-level 'workspaces.nohoist' directive is missing: ${missing.join(', ')}`,\n        fix: () => {\n          const packageJson = require(repoPackageJson); // eslint-disable-line @typescript-eslint/no-require-imports\n          packageJson.workspaces.nohoist = [...packageJson.workspaces.nohoist, ...missing].sort();\n          fs.writeFileSync(repoPackageJson, `${JSON.stringify(packageJson, null, 2)}\\n`, { encoding: 'utf8' });\n        },\n      });\n    }\n  }\n}", "language": "typescript"}
{"input": "CDK class EKSCluster for AWS resource management", "output": "class EKSCluster extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // Create a new VPC for our cluster\n    const vpc = new ec2.Vpc(this, \"EKSVpc\");\n\n    // Create Cluster with no default capacity (node group will be added later)\n    const eksCluster = new eks.Cluster(this, \"EKSCluster\", {\n      vpc: vpc,\n      defaultCapacity: 0,\n      version: kubernetesVersion,\n      kubectlLayer: new KubectlLayer(this, \"kubectl\"),\n      ipFamily: eks.IpFamily.IP_V4,\n      clusterLogging: clusterLogging,\n    });\n\n    // HINT: required cdk v2.135.0 or higher version to support instanceTypes assignment when working with AL2023\n    // - https://github.com/aws/aws-cdk/pull/29505\n    // - https://github.com/aws/aws-cdk/releases/tag/v2.135.0\n    eksCluster.addNodegroupCapacity(\"custom-node-group\", {\n      amiType: eks.NodegroupAmiType.AL2023_X86_64_STANDARD,\n      instanceTypes: instanceTypes,\n      desiredSize: 2,\n      minSize: 2,\n      maxSize: 5,\n      diskSize: 20,\n      nodeRole: new iam.Role(this, \"eksClusterNodeGroupRole\", {\n        roleName: \"eksClusterNodeGroupRole\",\n        assumedBy: new iam.ServicePrincipal(\"ec2.amazonaws.com\"),\n        managedPolicies: [\n          \"AmazonEKSWorkerNodePolicy\",\n          \"AmazonEC2ContainerRegistryPullOnly\",\n          \"AmazonEKS_CNI_Policy\",\n        ].map((policy) => iam.ManagedPolicy.fromAwsManagedPolicyName(policy)),\n      }),\n    });\n\n    // Fargate\n    new eks.FargateProfile(this, \"myProfile\", {\n      cluster: eksCluster,\n      selectors: [{ namespace: \"default\" }],\n    });\n\n    // Managed Addons\n    const addManagedAddon = (id: string, addonName: string) => {\n      new eks.CfnAddon(this, id, {\n        addonName,\n        clusterName: eksCluster.clusterName,\n      });\n    };\n\n    addManagedAddon(\"addonKubeProxy\", \"kube-proxy\");\n    addManagedAddon(\"addonCoreDns\", \"coredns\");\n    addManagedAddon(\"addonVpcCni\", \"vpc-cni\");\n    addManagedAddon(\"addonEksPodIdentityAgent\", \"eks-pod-identity-agent\");\n    addManagedAddon(\"addonMetricsServer\", \"metrics-server\");\n  }\n}", "language": "typescript"}
{"input": "CDK helper function for DynamoDB, IAM operations", "output": "def __init__(self, scope: Construct, id: str, **kwargs) -> None:\n        super().__init__(scope, id, **kwargs)\n\n        table_name = 'items'\n\n        items_graphql_api = CfnGraphQLApi(\n            self, 'ItemsApi',\n            name='items-api',\n            authentication_type='API_KEY'\n        )\n\n        CfnApiKey(\n            self, 'ItemsApiKey',\n            api_id=items_graphql_api.attr_api_id\n        )\n\n        api_schema = CfnGraphQLSchema(\n            self, 'ItemsSchema',\n            api_id=items_graphql_api.attr_api_id,\n            definition=f\"\"\"\\\n                type {table_name} {{\n                    {table_name}Id: ID!\n                    name: String\n                }}\n                type Paginated{table_name} {{\n                    items: [{table_name}!]!\n                    nextToken: String\n                }}\n                type Query {{\n                    all(limit: Int, nextToken: String): Paginated{table_name}!\n                    getOne({table_name}Id: ID!): {table_name}\n                }}\n                type Mutation {{\n                    save(name: String!): {table_name}\n                    delete({table_name}Id: ID!): {table_name}\n                }}\n                type Schema {{\n                    query: Query\n                    mutation: Mutation\n                }}\"\"\"\n        )\n\n        items_table = Table(\n            self, 'ItemsTable',\n            table_name=table_name,\n            partition_key=Attribute(\n                name=f'{table_name}Id',\n                type=AttributeType.STRING\n            ),\n            billing_mode=BillingMode.PAY_PER_REQUEST,\n            stream=StreamViewType.NEW_IMAGE,\n\n            # The default removal policy is RETAIN, which means that cdk\n            # destroy will not attempt to delete the new table, and it will\n            # remain in your account until manually deleted. By setting the\n            # policy to DESTROY, cdk destroy will delete the table (even if it\n            # has data in it)\n            removal_policy=RemovalPolicy.DESTROY  # NOT recommended for production code\n        )\n\n        items_table_role = Role(\n            self, 'ItemsDynamoDBRole',\n            assumed_by=ServicePrincipal('appsync.amazonaws.com')\n        )\n\n        items_table_role.add_managed_policy(\n            ManagedPolicy.from_aws_managed_policy_name(\n                'AmazonDynamoDBFullAccess'\n            )\n        )\n\n        data_source = CfnDataSource(\n            self, 'ItemsDataSource',\n            api_id=items_graphql_api.attr_api_id,\n            name='ItemsDynamoDataSource',\n            type='AMAZON_DYNAMODB',\n            dynamo_db_config=CfnDataSource.DynamoDBConfigProperty(\n                table_name=items_table.table_name,\n                aws_region=self.region\n            ),\n            service_role_arn=items_table_role.role_arn\n        )\n\n        get_one_resolver = CfnResolver(\n            self, 'GetOneQueryResolver',\n            api_id=items_graphql_api.attr_api_id,\n            type_name='Query',\n            field_name='getOne',\n            data_source_name=data_source.name,\n            request_mapping_template=f\"\"\"\\\n            {{\n                \"version\": \"2017-02-28\",\n                \"operation\": \"GetItem\",\n                \"key\": {{\n                \"{table_name}Id\": $util.dynamodb.toDynamoDBJson($ctx.args.{table_name}Id)\n                }}\n            }}\"\"\",\n            response_mapping_template=\"$util.toJson($ctx.result)\"\n        )\n\n        get_one_resolver.add_dependency(api_schema)\n        get_one_resolver.add_dependency(data_source)\n\n        get_all_resolver = CfnResolver(\n            self, 'GetAllQueryResolver',\n            api_id=items_graphql_api.attr_api_id,\n            type_name='Query',\n            field_name='all',\n            data_source_name=data_source.name,\n            request_mapping_template=f\"\"\"\\\n            {{\n                \"version\": \"2017-02-28\",\n                \"operation\": \"Scan\",\n                \"limit\": $util.defaultIfNull($ctx.args.limit, 20),\n                \"nextToken\": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.nextToken, null))\n            }}\"\"\",\n            response_mapping_template=\"$util.toJson($ctx.result)\"\n        )\n\n        get_all_resolver.add_dependency(api_schema)\n        get_all_resolver.add_dependency(data_source)\n\n        save_resolver = CfnResolver(\n            self, 'SaveMutationResolver',\n            api_id=items_graphql_api.attr_api_id,\n            type_name='Mutation',\n            field_name='save',\n            data_source_name=data_source.name,\n            request_mapping_template=f\"\"\"\\\n            {{\n                \"version\": \"2017-02-28\",\n                \"operation\": \"PutItem\",\n                \"key\": {{\n                    \"{table_name}Id\": {{ \"S\": \"$util.autoId()\" }}\n                }},\n                \"attributeValues\": {{\n                    \"name\": $util.dynamodb.toDynamoDBJson($ctx.args.name)\n                }}\n            }}\"\"\",\n            response_mapping_template=\"$util.toJson($ctx.result)\"\n        )\n\n        save_resolver.add_dependency(api_schema)\n        save_resolver.add_dependency(data_source)\n\n        delete_resolver = CfnResolver(\n            self, 'DeleteMutationResolver',\n            api_id=items_graphql_api.attr_api_id,\n            type_name='Mutation',\n            field_name='delete',\n            data_source_name=data_source.name,\n            request_mapping_template=f\"\"\"\\\n            {{\n                \"version\": \"2017-02-28\",\n                \"operation\": \"DeleteItem\",\n                \"key\": {{\n                \"{table_name}Id\": $util.dynamodb.toDynamoDBJson($ctx.args.{table_name}Id)\n                }}\n            }}\"\"\",\n            response_mapping_template=\"$util.toJson($ctx.result)\"\n        )\n\n        delete_resolver.add_dependency(api_schema)\n        delete_resolver.add_dependency(data_source)", "language": "python"}
{"input": "Static site infrastructure, which deploys site content to an S3 bucket.", "output": "export class StaticSiteBasic extends Construct {\n  constructor(parent: Stack, name: string, props: StaticSiteBasicProps) {\n    super(parent, name);\n\n    // Content bucket\n    const indexDocument = \"index.html\";\n\n    const websiteBucket = new s3.Bucket(this, \"WebsiteBucket\", {\n      websiteIndexDocument: indexDocument,\n      publicReadAccess: true,\n      blockPublicAccess: new s3.BlockPublicAccess({\n        blockPublicAcls: false,\n        blockPublicPolicy: false,\n        ignorePublicAcls: false,\n        restrictPublicBuckets: false,\n      }),\n      /**\n       * The default removal policy is RETAIN, which means that cdk destroy will not attempt to delete\n       * the new bucket, and it will remain in your account until manually deleted. By setting the policy to\n       * DESTROY, cdk destroy will attempt to delete the bucket, but will error if the bucket is not empty.\n       */\n      removalPolicy: RemovalPolicy.DESTROY, // NOT recommended for production code\n\n      /**\n       * For sample purposes only, if you create an S3 bucket then populate it, stack destruction fails.  This\n       * setting will enable full cleanup of the demo.\n       */\n      autoDeleteObjects: true, // NOT recommended for production code\n    });\n\n    new CfnOutput(this, \"Bucket\", { value: websiteBucket.bucketName });\n    new CfnOutput(this, \"StaticSiteUrl\", {\n      value: [\n        websiteBucket.bucketWebsiteUrl,\n        props.staticContentPrefix,\n        indexDocument,\n      ].join(\"/\"),\n    });\n\n    // Deploy site contents to S3 bucket\n    new s3deploy.BucketDeployment(this, \"DeployWebsite\", {\n      sources: [s3deploy.Source.asset(path.join(__dirname, \"./site-contents\"))],\n      destinationBucket: websiteBucket,\n      destinationKeyPrefix: props.staticContentPrefix, // optional prefix in destination bucket\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class WarmPool for AWS resource management", "output": "export class WarmPool extends Resource {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-autoscaling.WarmPool';\n\n  constructor(scope: Construct, id: string, props: WarmPoolProps) {\n    super(scope, id, {\n      physicalName: Lazy.string({ produce: () => Names.uniqueId(this) }),\n    });\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    if (props.maxGroupPreparedCapacity && props.maxGroupPreparedCapacity < -1) {\n      throw new ValidationError('\\'maxGroupPreparedCapacity\\' parameter should be greater than or equal to -1', this);\n    }\n\n    if (props.minSize && props.minSize < 0) {\n      throw new ValidationError('\\'minSize\\' parameter should be greater than or equal to 0', this);\n    }\n\n    new CfnWarmPool(this, 'Resource', {\n      autoScalingGroupName: props.autoScalingGroup.autoScalingGroupRef.autoScalingGroupName,\n      instanceReusePolicy: props.reuseOnScaleIn !== undefined ? {\n        reuseOnScaleIn: props.reuseOnScaleIn,\n      } : undefined,\n      maxGroupPreparedCapacity: props.maxGroupPreparedCapacity,\n      minSize: props.minSize,\n      poolState: props.poolState,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class Model for AWS resource management", "output": "export class Model extends ModelBase {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = '@aws-cdk.aws-sagemaker-alpha.Model';\n\n  /**\n   * Imports a Model defined either outside the CDK or in a different CDK stack.\n   * @param scope the Construct scope.\n   * @param id the resource id.\n   * @param modelArn the ARN of the model.\n   */\n  public static fromModelArn(scope: Construct, id: string, modelArn: string): IModel {\n    return Model.fromModelAttributes(scope, id, { modelArn });\n  }\n\n  /**\n   * Imports a Model defined either outside the CDK or in a different CDK stack.\n   * @param scope the Construct scope.\n   * @param id the resource id.\n   * @param modelName the name of the model.\n   */\n  public static fromModelName(scope: Construct, id: string, modelName: string): IModel {\n    const modelArn = cdk.Stack.of(scope).formatArn({\n      service: 'sagemaker',\n      resource: 'model',\n      resourceName: modelName,\n    });\n    return Model.fromModelAttributes(scope, id, { modelArn });\n  }\n\n  /**\n   * Imports a Model defined either outside the CDK or in a different CDK stack.\n   * @param scope the Construct scope.\n   * @param id the resource id.\n   * @param attrs the attributes of the model to import.\n   */\n  public static fromModelAttributes(scope: Construct, id: string, attrs: ModelAttributes): IModel {\n    const modelArn = attrs.modelArn;\n    const modelName = cdk.Stack.of(scope).splitArn(modelArn, cdk.ArnFormat.SLASH_RESOURCE_NAME).resourceName!;\n    const role = attrs.role;\n\n    class Import extends ModelBase {\n      public readonly modelArn = modelArn;\n      public readonly modelName = modelName;\n      public readonly role = role;\n      public readonly grantPrincipal: iam.IPrincipal;\n\n      constructor(s: Construct, i: string) {\n        super(s, i, {\n          environmentFromArn: attrs.modelArn,\n        });\n\n        this.grantPrincipal = role || new iam.UnknownPrincipal({ resource: this });\n        if (attrs.securityGroups) {\n          this._connections = new ec2.Connections({\n            securityGroups: attrs.securityGroups,\n          });\n        }\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * Returns the ARN of this model.\n   * @attribute\n   */\n  public readonly modelArn: string;\n  /**\n   * Returns the name of the model.\n   * @attribute\n   */\n  public readonly modelName: string;\n  /**\n   * Execution role for SageMaker Model\n   */\n  public readonly role?: iam.IRole;\n  /**\n   * The principal this Model is running as\n   */\n  public readonly grantPrincipal: iam.IPrincipal;\n  private readonly subnets: ec2.SelectedSubnets | undefined;\n  private readonly containers: CfnModel.ContainerDefinitionProperty[] = [];\n\n  constructor(scope: Construct, id: string, props: ModelProps = {}) {\n    super(scope, id, {\n      physicalName: props.modelName,\n    });\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    this._connections = this.configureNetworking(props);\n    this.subnets = (props.vpc) ? props.vpc.selectSubnets(props.vpcSubnets) : undefined;\n\n    // set the sagemaker role or create new one\n    this.role = props.role || this.createSageMakerRole();\n    this.grantPrincipal = this.role;\n\n    (props.containers || []).map(c => this.addContainer(c));\n\n    const model = new CfnModel(this, 'Model', {\n      executionRoleArn: this.role.roleArn,\n      modelName: this.physicalName,\n      primaryContainer: cdk.Lazy.any({ produce: () => this.renderPrimaryContainer() }),\n      vpcConfig: cdk.Lazy.any({ produce: () => this.renderVpcConfig() }),\n      containers: cdk.Lazy.any({ produce: () => this.renderContainers() }),\n      enableNetworkIsolation: props.networkIsolation,\n    });\n    this.modelName = this.getResourceNameAttribute(model.attrModelName);\n    this.modelArn = this.getResourceArnAttribute(model.ref, {\n      service: 'sagemaker',\n      resource: 'model',\n      resourceName: this.physicalName,\n    });\n\n    /*\n     * SageMaker model creation will fail if the model's execution role does not have read access to\n     * its model data in S3. Since the CDK uses a separate AWS::IAM::Policy CloudFormation resource\n     * to attach inline policies to IAM roles, the following line ensures that the role and its\n     * AWS::IAM::Policy resource are deployed prior to model creation.\n     */\n    model.node.addDependency(this.role);\n  }\n\n  /**\n   * Add containers to the model.\n   *\n   * @param container The container definition to add.\n   */\n  @MethodMetadata()\n  public addContainer(container: ContainerDefinition): void {\n    this.containers.push(this.renderContainer(container));\n  }\n\n  private validateContainers(): void {\n    // validate number of containers\n    if (this.containers.length < 1) {\n      throw new Error('Must configure at least 1 container for model');\n    } else if (this.containers.length > 15) {\n      throw new Error('Cannot have more than 15 containers in inference pipeline');\n    }\n  }\n\n  private renderPrimaryContainer(): CfnModel.ContainerDefinitionProperty | undefined {\n    return (this.containers.length === 1) ? this.containers[0] : undefined;\n  }\n\n  private renderContainers(): CfnModel.ContainerDefinitionProperty[] | undefined {\n    this.validateContainers();\n    return (this.containers.length === 1) ? undefined : this.containers;\n  }\n\n  private renderContainer(container: ContainerDefinition): CfnModel.ContainerDefinitionProperty {\n    return {\n      image: container.image.bind(this, this).imageName,\n      containerHostname: container.containerHostname,\n      environment: container.environment,\n      modelDataUrl: container.modelData ? container.modelData.bind(this, this).uri : undefined,\n    };\n  }\n\n  private configureNetworking(props: ModelProps): ec2.Connections | undefined {\n    if ((props.securityGroups || props.allowAllOutbound !== undefined) && !props.vpc) {\n      throw new Error('Cannot configure \\'securityGroups\\' or \\'allowAllOutbound\\' without configuring a VPC');\n    }\n\n    if (!props.vpc) { return undefined; }\n\n    if ((props.securityGroups && props.securityGroups.length > 0) && props.allowAllOutbound !== undefined) {\n      throw new Error('Configure \\'allowAllOutbound\\' directly on the supplied SecurityGroups');\n    }\n\n    let securityGroups: ec2.ISecurityGroup[];\n    if (props.securityGroups && props.securityGroups.length > 0) {\n      securityGroups = props.securityGroups;\n    } else {\n      const securityGroup = new ec2.SecurityGroup(this, 'SecurityGroup', {\n        vpc: props.vpc,\n        allowAllOutbound: props.allowAllOutbound,\n      });\n      securityGroups = [securityGroup];\n    }\n\n    return new ec2.Connections({ securityGroups });\n  }", "language": "typescript"}
{"input": "Requires projectReferences to be set in the jsii configuration.", "output": "export class JSIIProjectReferences extends ValidationRule {\n  public readonly name = 'jsii/project-references';\n\n  public validate(pkg: PackageJson): void {\n    if (!isJSII(pkg)) {\n      return;\n    }\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates CloudFormation, ECS, ECR resources", "output": "class JavaStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props: ApplicationSignalsStackProps) {\n    super(scope, id, props);\n\n    const taskDefinition = new ecs.Ec2TaskDefinition(this, 'JavaTaskDefinition', {\n      taskRole: props.taskRole,\n      executionRole: props.taskExecutionRole,\n      networkMode: ecs.NetworkMode.HOST,\n    });\n\n    taskDefinition.addContainer('app', {\n      image: ecs.ContainerImage.fromRegistry('public.ecr.aws/aws-containers/retail-store-sample-cart:1.1.0'),\n      memoryLimitMiB: 512,\n    });\n\n    new appsignals.ApplicationSignalsIntegration(this, 'JavaECSIntegration', {\n      taskDefinition: taskDefinition,\n      instrumentation: {\n        sdkVersion: appsignals.JavaInstrumentationVersion.V2_10_0,\n      },\n      serviceName: 'java-demo',\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class VpnConnection for AWS resource management", "output": "export class VpnConnection extends VpnConnectionBase {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-ec2.VpnConnection';\n\n  /**\n   * Import a VPN connection by supplying all attributes directly\n   */\n  public static fromVpnConnectionAttributes(scope: Construct, id: string, attrs: VpnConnectionAttributes): IVpnConnection {\n    class Import extends VpnConnectionBase {\n      public readonly vpnId: string = attrs.vpnId;\n      public readonly customerGatewayId: string = attrs.customerGatewayId;\n      public readonly customerGatewayIp: string = attrs.customerGatewayIp;\n      public readonly customerGatewayAsn: number = attrs.customerGatewayAsn;\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * Return the given named metric for all VPN connections in the account/region.\n   */\n  public static metricAll(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/VPN',\n      metricName,\n      ...props,\n    });\n  }\n\n  /**\n   * Metric for the tunnel state of all VPN connections in the account/region.\n   *\n   * @default average over 5 minutes\n   */\n  public static metricAllTunnelState(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('TunnelState', { statistic: 'avg', ...props });\n  }\n\n  /**\n   * Metric for the tunnel data in of all VPN connections in the account/region.\n   *\n   * @default sum over 5 minutes\n   */\n  public static metricAllTunnelDataIn(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('TunnelDataIn', { statistic: 'sum', ...props });\n  }\n\n  /**\n   * Metric for the tunnel data out of all VPN connections.\n   *\n   * @default sum over 5 minutes\n   */\n  public static metricAllTunnelDataOut(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('TunnelDataOut', { statistic: 'sum', ...props });\n  }\n\n  public readonly vpnId: string;\n  public readonly customerGatewayId: string;\n  public readonly customerGatewayIp: string;\n  public readonly customerGatewayAsn: number;\n\n  constructor(scope: Construct, id: string, props: VpnConnectionProps) {\n    super(scope, id);\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    if (!props.vpc.vpnGatewayId) {\n      props.vpc.enableVpnGateway({\n        type: 'ipsec.1',\n        amazonSideAsn: props.asn,\n      });\n    }\n\n    if (!Token.isUnresolved(props.ip) && !net.isIPv4(props.ip)) {\n      throw new ValidationError(`The \\`ip\\` ${props.ip} is not a valid IPv4 address.`, this);\n    }\n\n    const type = VpnConnectionType.IPSEC_1;\n    const bgpAsn = props.asn || 65000;\n\n    const customerGateway = new CfnCustomerGateway(this, 'CustomerGateway', {\n      bgpAsn,\n      ipAddress: props.ip,\n      type,\n    });\n\n    this.customerGatewayId = customerGateway.ref;\n    this.customerGatewayAsn = bgpAsn;\n    this.customerGatewayIp = props.ip;\n\n    // Validate tunnel options\n    if (props.tunnelOptions) {\n      if (props.tunnelOptions.length > 2) {\n        throw new ValidationError('Cannot specify more than two `tunnelOptions`', this);\n      }\n\n      if (props.tunnelOptions.length === 2 &&\n        props.tunnelOptions[0].tunnelInsideCidr === props.tunnelOptions[1].tunnelInsideCidr &&\n        props.tunnelOptions[0].tunnelInsideCidr !== undefined) {\n        throw new ValidationError(`Same ${props.tunnelOptions[0].tunnelInsideCidr} \\`tunnelInsideCidr\\` cannot be used for both tunnels.`, this);\n      }\n\n      props.tunnelOptions.forEach((options, index) => {\n        if (options.preSharedKey && options.preSharedKeySecret) {\n          throw new ValidationError(\"Specify at most one of 'preSharedKey' and 'preSharedKeySecret'.\", this);\n        }\n\n        if (options.preSharedKey && !Token.isUnresolved(options.preSharedKey) && !/^[a-zA-Z1-9._][a-zA-Z\\d._]{7,63}$/.test(options.preSharedKey)) {\n          throw new ValidationError(`The \\`preSharedKey\\` ${options.preSharedKey} for tunnel ${index + 1} is invalid. Allowed characters are alphanumeric characters and ._. Must be between 8 and 64 characters in length and cannot start with zero (0).`, this);\n        }\n\n        if (options.tunnelInsideCidr) {\n          if (RESERVED_TUNNEL_INSIDE_CIDR.includes(options.tunnelInsideCidr)) {\n            throw new ValidationError(`The \\`tunnelInsideCidr\\` ${options.tunnelInsideCidr} for tunnel ${index + 1} is a reserved inside CIDR.`, this);\n          }\n\n          if (!/^169\\.254\\.\\d{1,3}\\.\\d{1,3}\\/30$/.test(options.tunnelInsideCidr)) {\n            throw new ValidationError(`The \\`tunnelInsideCidr\\` ${options.tunnelInsideCidr} for tunnel ${index + 1} is not a size /30 CIDR block from the 169.254.0.0/16 range.`, this);\n          }\n        }\n      });\n    }\n\n    const vpnConnection = new CfnVPNConnection(this, 'Resource', {\n      type,\n      customerGatewayId: customerGateway.ref,\n      staticRoutesOnly: props.staticRoutes ? true : false,\n      vpnGatewayId: props.vpc.vpnGatewayId,\n      vpnTunnelOptionsSpecifications: props.tunnelOptions?.map(t => ({\n        preSharedKey: t.preSharedKeySecret?.unsafeUnwrap() ?? t.preSharedKey,\n        tunnelInsideCidr: t.tunnelInsideCidr,\n      })),\n    });\n\n    this.vpnId = vpnConnection.ref;\n\n    if (props.staticRoutes) {\n      props.staticRoutes.forEach(route => {\n        new CfnVPNConnectionRoute(this, `Route${route.replace(/[^\\d]/g, '')}`, {\n          destinationCidrBlock: route,\n          vpnConnectionId: this.vpnId,\n        });\n      });\n    }\n  }\n}", "language": "typescript"}
{"input": "CDK helper function for MSK (Kafka), ECS, EKS operations", "output": "const setupTest = (authenticationMode?: AuthenticationMode) => {\n    const { stack } = testFixture();\n    const cluster = new Cluster(stack, 'Cluster', {\n      version: KubernetesVersion.V1_27,\n      authenticationMode,\n      kubectlLayer: new KubectlV31Layer(stack, 'KubectlLayer'),\n    });\n    AlbController.create(stack, {\n      cluster,\n      version: AlbControllerVersion.V2_6_2,\n    });\n    return stack;\n  }", "language": "typescript"}
{"input": "CDK class Packaging for AWS resource management", "output": "export class Packaging {\n  /**\n   * Standard packaging with `pip`.\n   */\n  public static withPip(): Packaging {\n    return new Packaging({\n      dependenciesFile: DependenciesFile.PIP,\n    });\n  }\n\n  /**\n   * Packaging with `pipenv`.\n   */\n  public static withPipenv(): Packaging {\n    return new Packaging({\n      dependenciesFile: DependenciesFile.PIPENV,\n      // By default, pipenv creates a virtualenv in `/.local`, so we force it to create one in the package directory.\n      // At the end, we remove the virtualenv to avoid creating a duplicate copy in the Lambda package.\n      exportCommand: `PIPENV_VENV_IN_PROJECT=1 pipenv requirements > ${DependenciesFile.PIP} && rm -rf .venv`,\n    });\n  }\n\n  /**\n   * Packaging with `poetry`.\n   */\n  public static withPoetry(props?: PoetryPackagingProps) {\n    return new Packaging({\n      dependenciesFile: DependenciesFile.POETRY,\n      // Export dependencies with credentials available in the bundling image.\n      exportCommand: [\n        'poetry', 'export',\n        ...props?.poetryIncludeHashes ? [] : ['--without-hashes'],\n        ...props?.poetryWithoutUrls ? ['--without-urls'] : [],\n        '--with-credentials',\n        '--format', DependenciesFile.PIP,\n        '--output', DependenciesFile.PIP,\n      ].join(' '),\n    });\n  }\n\n  /**\n   * Packaging with `uv`.\n   */\n  public static withUv() {\n    return new Packaging({\n      dependenciesFile: DependenciesFile.UV,\n      exportCommand: `uv export --frozen --no-emit-workspace --no-dev --no-editable -o ${DependenciesFile.PIP}`,\n    });\n  }\n\n  /**\n   * No dependencies or packaging.\n   */\n  public static withNoPackaging(): Packaging {\n    return new Packaging({ dependenciesFile: DependenciesFile.NONE });\n  }\n\n  public static fromEntry(entry: string, poetryIncludeHashes?: boolean, poetryWithoutUrls?: boolean): Packaging {\n    if (fs.existsSync(path.join(entry, DependenciesFile.PIPENV))) {\n      return this.withPipenv();\n    } if (fs.existsSync(path.join(entry, DependenciesFile.POETRY))) {\n      return this.withPoetry({ poetryIncludeHashes, poetryWithoutUrls });\n    } else if (fs.existsSync(path.join(entry, DependenciesFile.PIP))) {\n      return this.withPip();\n    } else if (fs.existsSync(path.join(entry, DependenciesFile.UV))) {\n      return this.withUv();\n    } else {\n      return this.withNoPackaging();\n    }\n  }\n\n  public readonly dependenciesFile: string;\n  public readonly exportCommand?: string;\n  constructor(props: PackagingProps) {\n    this.dependenciesFile = props.dependenciesFile;\n    this.exportCommand = props.exportCommand;\n  }\n}", "language": "typescript"}
{"input": "CDK class S3BucketOriginWithOAC for AWS resource management", "output": "class S3BucketOriginWithOAC extends S3BucketOrigin {\n  private readonly bucket: IBucket;\n  private originAccessControl?: IOriginAccessControlRef;\n  private originAccessLevels?: cloudfront.AccessLevel[];\n\n  constructor(bucket: IBucket, props?: S3BucketOriginWithOACProps) {\n    super(bucket, { ...props });\n    this.bucket = bucket;\n    this.originAccessControl = props?.originAccessControl;\n    this.originAccessLevels = props?.originAccessLevels;\n  }\n\n  public bind(scope: Construct, options: cloudfront.OriginBindOptions): cloudfront.OriginBindConfig {\n    if (!this.originAccessControl) {\n      this.originAccessControl = new cloudfront.S3OriginAccessControl(scope, 'S3OriginAccessControl');\n    }\n\n    const distributionId = options.distributionId;\n    const accessLevels = new Set(this.originAccessLevels ?? [cloudfront.AccessLevel.READ]);\n    if (accessLevels.has(AccessLevel.LIST)) {\n      Annotations.of(scope).addWarningV2('@aws-cdk/aws-cloudfront-origins:listBucketSecurityRisk',\n        'When the origin with AccessLevel.LIST is associated to the default behavior, '+\n        'it is strongly recommended to ensure the distribution\\'s defaultRootObject is specified,\\n'+\n        'See the \"Setting up OAC with LIST permission\" section of module\\'s README for more info.');\n    }\n\n    const bucketPolicyActions = this.getBucketPolicyActions(accessLevels);\n    const bucketPolicyResult = this.grantDistributionAccessToBucket(distributionId!, bucketPolicyActions);\n\n    // Failed to update bucket policy, assume using imported bucket\n    if (!bucketPolicyResult.statementAdded) {\n      Annotations.of(scope).addWarningV2('@aws-cdk/aws-cloudfront-origins:updateImportedBucketPolicyOac',\n        'Cannot update bucket policy of an imported bucket. You will need to update the policy manually instead.\\n' +\n        'See the \"Setting up OAC with imported S3 buckets\" section of module\\'s README for more info.');\n    }\n\n    if (this.bucket.encryptionKey) {\n      const keyPolicyActions = this.getKeyPolicyActions(accessLevels);\n      const keyPolicyResult = this.grantDistributionAccessToKey(keyPolicyActions, this.bucket.encryptionKey);\n      // Failed to update key policy, assume using imported key\n      if (!keyPolicyResult.statementAdded) {\n        Annotations.of(scope).addWarningV2('@aws-cdk/aws-cloudfront-origins:updateImportedKeyPolicyOac',\n          'Cannot update key policy of an imported key. You will need to update the policy manually instead.\\n' +\n          'See the \"Updating imported key policies\" section of the module\\'s README for more info.');\n      }\n    }\n\n    const originBindConfig = this._bind(scope, options);\n\n    // Update configuration to set OriginControlAccessId property\n    return {\n      ...originBindConfig,\n      originProperty: {\n        ...originBindConfig.originProperty!,\n        originAccessControlId: this.originAccessControl.originAccessControlRef.originAccessControlId,\n      },\n    };\n  }\n\n  private getBucketPolicyActions(accessLevels: Set<cloudfront.AccessLevel>): BucketPolicyAction[] {\n    return [...accessLevels].flatMap((accessLevel) => BUCKET_ACTIONS[accessLevel] ?? []);\n  }\n\n  private getKeyPolicyActions(accessLevels: Set<cloudfront.AccessLevel>): string[] {\n    return [...accessLevels].flatMap((accessLevel) => KEY_ACTIONS[accessLevel] ?? []);\n  }\n\n  private grantDistributionAccessToBucket(distributionId: string, policyActions: BucketPolicyAction[]): iam.AddToResourcePolicyResult {\n    const resources = [this.bucket.arnForObjects('*')];\n    if (policyActions.some((pa) => pa.needsBucketArn)) {\n      resources.push(this.bucket.bucketArn);\n    }\n    const oacBucketPolicyStatement = new iam.PolicyStatement(\n      {\n        effect: iam.Effect.ALLOW,\n        principals: [new iam.ServicePrincipal('cloudfront.amazonaws.com')],\n        actions: policyActions.map((pa) => pa.action),\n        resources,\n        conditions: {\n          StringEquals: {\n            'AWS:SourceArn': `arn:${Aws.PARTITION}:cloudfront::${Aws.ACCOUNT_ID}:distribution/${distributionId}`,\n          },\n        },\n      },\n    );\n    const result = this.bucket.addToResourcePolicy(oacBucketPolicyStatement);\n    return result;\n  }\n\n  private grantDistributionAccessToKey(actions: string[], key: IKey): iam.AddToResourcePolicyResult {\n    const oacKeyPolicyStatement = new iam.PolicyStatement(\n      {\n        effect: iam.Effect.ALLOW,\n        principals: [new iam.ServicePrincipal('cloudfront.amazonaws.com')],\n        actions,\n        resources: ['*'],\n        conditions: {\n          ArnLike: {\n            'AWS:SourceArn': `arn:${Aws.PARTITION}:cloudfront::${Aws.ACCOUNT_ID}:distribution/*`,\n          },\n        },\n      },\n    );\n    Annotations.of(key.node.scope!).addWarningV2('@aws-cdk/aws-cloudfront-origins:wildcardKeyPolicyForOac',\n      'To avoid a circular dependency between the KMS key, Bucket, and Distribution during the initial deployment, ' +\n      'a wildcard is used in the Key policy condition to match all Distribution IDs.\\n' +\n      'After deploying once, it is strongly recommended to further scope down the policy for best security practices by ' +\n      'following the guidance in the \"Using OAC for a SSE-KMS encrypted S3 origin\" section in the module README.');\n    const result = key.addToResourcePolicy(oacKeyPolicyStatement);\n    return result;\n  }\n}", "language": "typescript"}
{"input": "CDK class BucketApplicationCode for AWS resource management", "output": "class BucketApplicationCode extends ApplicationCode {\n  public readonly bucket?: s3.IBucket;\n  public readonly fileKey: string;\n  public readonly objectVersion?: string;\n\n  constructor(props: BucketApplicationCodeProps) {\n    super();\n    this.bucket = props.bucket;\n    this.fileKey = props.fileKey;\n    this.objectVersion = props.objectVersion;\n  }\n\n  public bind(_scope: Construct): ApplicationCodeConfig {\n    return {\n      applicationCodeConfigurationProperty: {\n        applicationCodeConfiguration: {\n          codeContent: {\n            s3ContentLocation: {\n              bucketArn: this.bucket!.bucketArn,\n              fileKey: this.fileKey,\n              objectVersion: this.objectVersion,\n            },\n          },\n          codeContentType: 'ZIPFILE',\n        },\n      },\n      bucket: this.bucket!,\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates SSM Parameter Store, CloudFormation, Lake Formation resources", "output": "class ProducingStack extends cdk.Stack {\n  readonly resourceShareArn: string;\n  readonly parameterArn: string;\n  constructor(scope: cdk.App, id: string, props: ProducingStackProps) {\n    super(scope, id, props);\n\n    const publicParameter = new ssm.StringParameter(this, 'String', {\n      parameterName,\n      stringValue: 'Abc123',\n      tier: ssm.ParameterTier.ADVANCED,\n    });\n\n    this.parameterArn = publicParameter.parameterArn;\n\n    // create resource share\n    const share = new ram.CfnResourceShare(this, 'ParamShare', {\n      name: 'ParamShare',\n      allowExternalPrincipals: true,\n      principals: [props.sharingToAccount],\n      resourceArns: [this.parameterArn],\n      permissionArns: [\n        'arn:aws:ram::aws:permission/AWSRAMDefaultPermissionSSMParameterReadOnly',\n      ],\n    });\n\n    this.resourceShareArn = share.attrArn;\n    new cdk.CfnOutput(this, 'ResourceShareArn', { value: this.resourceShareArn });\n    new cdk.CfnOutput(this, 'ParameterArn', { value: this.parameterArn });\n\n    share.node.addDependency(publicParameter);\n  }\n}", "language": "typescript"}
{"input": "CDK class PySparkEtlJob for AWS resource management", "output": "export class PySparkEtlJob extends SparkJob {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = '@aws-cdk.aws-glue-alpha.PySparkEtlJob';\n  public readonly jobArn: string;\n  public readonly jobName: string;\n\n  /**\n   * PySparkEtlJob constructor\n   */\n  constructor(scope: Construct, id: string, props: PySparkEtlJobProps) {\n    super(scope, id, props);\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    // Combine command line arguments into a single line item\n    const defaultArguments = {\n      ...this.executableArguments(props),\n      ...this.nonExecutableCommonArguments(props),\n    };\n\n    const jobResource = new CfnJob(this, 'Resource', {\n      name: props.jobName,\n      description: props.description,\n      role: this.role.roleArn,\n      command: {\n        name: JobType.ETL,\n        scriptLocation: this.codeS3ObjectUrl(props.script),\n        pythonVersion: PythonVersion.THREE,\n      },\n      glueVersion: props.glueVersion ?? GlueVersion.V4_0,\n      workerType: props.workerType ?? WorkerType.G_1X,\n      numberOfWorkers: props.numberOfWorkers ? props.numberOfWorkers : 10,\n      maxRetries: props.jobRunQueuingEnabled ? 0 : props.maxRetries,\n      jobRunQueuingEnabled: props.jobRunQueuingEnabled ? props.jobRunQueuingEnabled : false,\n      executionProperty: props.maxConcurrentRuns ? { maxConcurrentRuns: props.maxConcurrentRuns } : undefined,\n      timeout: props.timeout?.toMinutes(),\n      connections: props.connections ? { connections: props.connections.map((connection) => connection.connectionName) } : undefined,\n      securityConfiguration: props.securityConfiguration?.securityConfigurationName,\n      tags: props.tags,\n      defaultArguments,\n    });\n\n    const resourceName = this.getResourceNameAttribute(jobResource.ref);\n    this.jobArn = this.buildJobArn(this, resourceName);\n    this.jobName = resourceName;\n  }\n\n  /**\n   * Set the executable arguments with best practices enabled by default\n   *\n   * @returns An array of arguments for Glue to use on execution\n   */\n  private executableArguments(props: PySparkEtlJobProps) {\n    const args: { [key: string]: string } = {};\n    args['--job-language'] = JobLanguage.PYTHON;\n    this.setupExtraCodeArguments(args, props);\n    return args;\n  }\n}", "language": "typescript"}
{"input": "Represents a message in a chat conversation.", "output": "export class ChatMessage {\n  /**\n   * Creates a user message.\n   *\n   * @param text - The text content of the user message\n   * @returns A ChatMessage instance representing a user message\n   */\n  public static user(text: string): ChatMessage {\n    return new ChatMessage(ChatMessageRole.USER, text);\n  }\n\n  /**\n   * Creates an assistant message.\n   *\n   * @param text - The text content of the assistant message\n   * @returns A ChatMessage instance representing an assistant message\n   */\n  public static assistant(text: string): ChatMessage {\n    return new ChatMessage(ChatMessageRole.ASSISTANT, text);\n  }\n\n  /**\n   * The role of the message sender.\n   */\n  public readonly role: ChatMessageRole;\n\n  /**\n   * The text content of the message.\n   */\n  public readonly text: string;\n\n  constructor(role: ChatMessageRole, text: string) {\n    this.role = role;\n    this.text = text;\n  }\n\n  /**\n   * Renders the message as a CloudFormation property.\n   * @internal This is an internal core function and should not be called directly.\n   */\n  public _render(): CfnPrompt.MessageProperty {\n    return {\n      role: this.role,\n      content: [\n        {\n          text: this.text,\n        },\n      ],\n    };\n  }\n}", "language": "typescript"}
{"input": "Test service with multiple placement strategies", "output": "class EcsWithStrategiesStack extends BaseEcsStack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n    const { cluster, taskDefinition } = this.createBaseResources();\n\n    new ecs.Ec2Service(this, 'Service', {\n      cluster,\n      taskDefinition,\n      placementStrategies: [\n        ecs.PlacementStrategy.packedByCpu(),\n        ecs.PlacementStrategy.packedByMemory(),\n      ],\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates DynamoDB, EC2, VPC, MSK (Kafka) resources", "output": "class SingleProviderRoleStack extends Stack {\n  private static databaseName = 'single-provider-role-integ-test.db';\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const vpc = new ec2.Vpc(this, 'VPC', { restrictDefaultSecurityGroup: false });\n    const cluster = new redshift.Cluster(this, 'Cluster', {\n      vpc,\n      vpcSubnets: {\n        subnetType: ec2.SubnetType.PUBLIC,\n      },\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      defaultDatabaseName: SingleProviderRoleStack.databaseName,\n      removalPolicy: RemovalPolicy.DESTROY,\n    });\n\n    for (let i = 0; i < 3; i++) {\n      new redshift.Table(this, `Table${i}`, {\n        cluster: cluster,\n        databaseName: SingleProviderRoleStack.databaseName,\n        tableColumns: [\n          { name: 'col1', dataType: 'varchar(4)', distKey: true, comment: 'A test column', encoding: redshift.ColumnEncoding.LZO },\n          { name: 'col2', dataType: 'float', sortKey: true, comment: 'A test column' },\n          { name: 'col3', dataType: 'float', comment: 'A test column', encoding: redshift.ColumnEncoding.RAW },\n        ],\n        distStyle: redshift.TableDistStyle.KEY,\n        sortStyle: redshift.TableSortStyle.INTERLEAVED,\n        tableComment: `A test table #${i}`,\n      });\n    }\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates KMS, CloudFormation resources", "output": "class TestStack extends Stack {\n  constructor(scope: App) {\n    super(scope, 'TestStack');\n    new Key(this, 'key', {\n      alias: `MyKey${this.account}`,\n    });\n  }\n}", "language": "typescript"}
{"input": "Verifies there is no dependency on \"jsii\" since it's defined at the repo level.", "output": "export class NoJsiiDep extends ValidationRule {\n  public readonly name = 'dependencies/no-jsii';\n\n  public validate(pkg: PackageJson): void {\n    const predicate = (s: string) => s.startsWith('jsii');\n\n    if (pkg.getDevDependency(predicate)) {\n      pkg.report({\n        ruleName: this.name,\n        message: 'packages should not have a devDep on jsii since it is defined at the repo level',\n        fix: () => pkg.removeDevDependency(predicate),\n      });\n    }\n  }\n}", "language": "typescript"}
{"input": "Credentials used for AWS Service integrations.", "output": "class IntegrationCredentials {\n  /**\n   * Use the specified role for integration requests\n   */\n  public static fromRole(role: IRoleRef): IntegrationCredentials {\n    return { credentialsArn: role.roleRef.roleArn };\n  }\n\n  /** Use the calling user's identity to call the integration */\n  public static useCallerIdentity(): IntegrationCredentials {\n    return { credentialsArn: `arn:${Aws.PARTITION}:iam::*:user/*` };\n  }\n\n  /**\n   * The ARN of the credentials\n   */\n  public abstract readonly credentialsArn: string;\n}\n\n/**\n * Supported connection types\n */\nexport enum HttpConnectionType {\n  /**\n   * For private connections between API Gateway and resources in a VPC\n   */\n  VPC_LINK = 'VPC_LINK',\n  /**\n   * For connections through public routable internet\n   */\n  INTERNET = 'INTERNET',\n}\n\n/**\n * Payload format version for lambda proxy integration\n * @see https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html\n */\nexport class PayloadFormatVersion {\n  /** Version 1.0 */\n  public static readonly VERSION_1_0 = new PayloadFormatVersion('1.0');\n  /** Version 2.0 */\n  public static readonly VERSION_2_0 = new PayloadFormatVersion('2.0');\n\n  /**\n   * A custom payload version.\n   * Typically used if there is a version number that the CDK doesn't support yet\n   */\n  public static custom(version: string) {\n    return new PayloadFormatVersion(version);\n  }\n\n  /** version as a string */\n  public readonly version: string;\n\n  private constructor(version: string) {\n    this.version = version;\n  }\n}", "language": "typescript"}
{"input": "How to validate a certificate", "output": "export class CertificateValidation {\n  /**\n   * Validate the certificate with DNS\n   *\n   * IMPORTANT: If `hostedZone` is not specified, DNS records must be added\n   * manually and the stack will not complete creating until the records are\n   * added.\n   *\n   * @param hostedZone the hosted zone where DNS records must be created\n   */\n  public static fromDns(hostedZone?: route53.IHostedZone) {\n    return new CertificateValidation({\n      method: ValidationMethod.DNS,\n      hostedZone,\n    });\n  }\n\n  /**\n   * Validate the certificate with automatically created DNS records in multiple\n   * Amazon Route 53 hosted zones.\n   *\n   * @param hostedZones a map of hosted zones where DNS records must be created\n   * for the domains in the certificate\n   */\n  public static fromDnsMultiZone(hostedZones: { [domainName: string]: route53.IHostedZone }) {\n    return new CertificateValidation({\n      method: ValidationMethod.DNS,\n      hostedZones,\n    });\n  }\n\n  /**\n   * Validate the certificate with Email\n   *\n   * IMPORTANT: if you are creating a certificate as part of your stack, the stack\n   * will not complete creating until you read and follow the instructions in the\n   * email that you will receive.\n   *\n   * ACM will send validation emails to the following addresses:\n   *\n   *  admin@domain.com\n   *  administrator@domain.com\n   *  hostmaster@domain.com\n   *  postmaster@domain.com\n   *  webmaster@domain.com\n   *\n   * For every domain that you register.\n   *\n   * @param validationDomains a map of validation domains to use for domains in the certificate\n   */\n  public static fromEmail(validationDomains?: { [domainName: string]: string }) {\n    return new CertificateValidation({\n      method: ValidationMethod.EMAIL,\n      validationDomains,\n    });\n  }\n\n  /**\n   * The validation method\n   */\n  public readonly method: ValidationMethod;\n\n  /** @param props Certification validation properties */\n  private constructor(public readonly props: CertificationValidationProps) {\n    this.method = props.method ?? ValidationMethod.EMAIL;\n  }\n}", "language": "typescript"}
{"input": "IpAddress options to define VPC V2", "output": "export class IpAddresses {\n  /**\n   * An IPv4 CIDR Range\n   */\n  public static ipv4(ipv4Cidr: string, props?: SecondaryAddressProps): IIpAddresses {\n    return new ipv4CidrAllocation(ipv4Cidr, props);\n  }\n\n  /**\n   * An Ipv4 Ipam Pool\n   */\n  public static ipv4Ipam(ipv4IpamOptions: IpamOptions): IIpAddresses {\n    return new IpamIpv4(ipv4IpamOptions);\n  }\n\n  /**\n   * An Ipv6 Ipam Pool\n   */\n  public static ipv6Ipam(ipv6IpamOptions: IpamOptions): IIpAddresses {\n    return new IpamIpv6(ipv6IpamOptions);\n  }\n\n  /**\n   * Amazon Provided Ipv6 range\n   */\n  public static amazonProvidedIpv6(props: SecondaryAddressProps) : IIpAddresses {\n    return new AmazonProvided(props);\n  }\n\n  /**\n   * A BYOIP IPv6 address pool\n   */\n  public static ipv6ByoipPool(props: Ipv6PoolSecondaryAddressProps): IIpAddresses {\n    return new Ipv6Pool(props);\n  }\n}", "language": "typescript"}
{"input": "CDK class ChatbotLogRetentionInteg for AWS resource management", "output": "class ChatbotLogRetentionInteg extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const slackChannel = new chatbot.SlackChannelConfiguration(this, 'MySlackChannel', {\n      slackChannelConfigurationName: 'test-channel',\n      slackWorkspaceId: 'T49239U4W', // modify to your slack workspace id\n      slackChannelId: 'C0187JABUE9', // modify to your slack channel id\n      loggingLevel: chatbot.LoggingLevel.NONE,\n      logRetention: logs.RetentionDays.ONE_MONTH,\n    });\n\n    slackChannel.addToRolePolicy(new iam.PolicyStatement({\n      effect: iam.Effect.ALLOW,\n      actions: [\n        's3:GetObject',\n      ],\n      resources: ['arn:aws:s3:::abc/xyz/123.txt'],\n    }));\n  }\n}", "language": "typescript"}
{"input": "CDK class S3OriginAccessControl for AWS resource management", "output": "export class S3OriginAccessControl extends OriginAccessControlBase {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-cloudfront.S3OriginAccessControl';\n\n  /**\n   * Imports an S3 origin access control from its id.\n   */\n  public static fromOriginAccessControlId(scope: Construct, id: string, originAccessControlId: string): IOriginAccessControl {\n    class Import extends Resource implements IOriginAccessControl {\n      public readonly originAccessControlId = originAccessControlId;\n      public readonly originAccessControlOriginType = OriginAccessControlOriginType.S3;\n\n      public get originAccessControlRef(): OriginAccessControlReference {\n        return {\n          originAccessControlId: this.originAccessControlId,\n        };\n      }\n    }\n    return new Import(scope, id);\n  }\n\n  /**\n   * The unique identifier of this Origin Access Control.\n   * @attribute\n   */\n  public readonly originAccessControlId: string;\n\n  constructor(scope: Construct, id: string, props: S3OriginAccessControlProps = {}) {\n    super(scope, id);\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    const resource = new CfnOriginAccessControl(this, 'Resource', {\n      originAccessControlConfig: {\n        description: props.description,\n        name: props.originAccessControlName ?? Names.uniqueResourceName(this, {\n          maxLength: 64,\n        }),\n        signingBehavior: props.signing?.behavior ?? SigningBehavior.ALWAYS,\n        signingProtocol: props.signing?.protocol ?? SigningProtocol.SIGV4,\n        originAccessControlOriginType: OriginAccessControlOriginType.S3,\n      },\n    });\n\n    this.originAccessControlId = resource.attrId;\n  }\n}", "language": "typescript"}
{"input": "Helper class for S3-based component data references, containing additional permission grant methods on the S3 object", "output": "class S3ComponentData extends ComponentData {\n  protected readonly bucket: s3.IBucket;\n  protected readonly key: string;\n\n  protected constructor(bucket: s3.IBucket, key: string) {\n    super();\n\n    this.bucket = bucket;\n    this.key = key;\n  }\n\n  /**\n   * The rendered component data text, for use in CloudFormation\n   */\n  public render(): ComponentDataConfig {\n    return { uri: this.bucket.s3UrlForObject(this.key) };\n  }\n\n  /**\n   * Grant put permissions to the given grantee for the component data in S3\n   * [disable-awslint:no-grants]\n   *\n   * @param grantee The principal\n   */\n  public grantPut(grantee: iam.IGrantable): iam.Grant {\n    return this.bucket.grantPut(grantee, this.key);\n  }\n\n  /**\n   * Grant read permissions to the given grantee for the component data in S3\n   * [disable-awslint:no-grants]\n   *\n   * @param grantee The principal\n   */\n  public grantRead(grantee: iam.IGrantable): iam.Grant {\n    return this.bucket.grantRead(grantee, this.key);\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates IAM, SSM Parameter Store, CloudFormation resources", "output": "class MyStack extends Stack {\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    const tagName = new CfnParameter(this, 'PrincipalTag', { default: 'developer' });\n\n    const stringEquals = new CfnJson(this, 'PrincipalTagCondition', {\n      value: {\n        [`aws:PrincipalTag/${tagName.valueAsString}`]: 'true',\n      },\n    });\n\n    const principal = new AccountRootPrincipal().withConditions({\n      StringEquals: stringEquals,\n    });\n\n    new Role(this, 'MyRole', { assumedBy: principal });\n  }\n}", "language": "typescript"}
{"input": "CDK class MySql for AWS resource management", "output": "class MySql(Stack):\n    def __init__(self, scope:Construct, id:str,\n                vpc_id:str,                 ## vpc id\n                subnet_ids:list,            ## list of subnet ids\n                db_name:str,                ## database name\n                instance_type = None,       ## ec2.InstanceType\n                engine_version = None,      ## MySQL Engine Version\n                **kwargs) -> None:\n        super().__init__(app, id, **kwargs)\n\n        azs = Fn.get_azs()\n\n        vpc = ec2.Vpc.from_vpc_attributes(self, 'ExistingVPC', availability_zones=azs, vpc_id=vpc_id)\n        subnets = list()\n        for subnet_id in subnet_ids:\n          subnets.append(ec2.Subnet.from_subnet_attributes(self, subnet_id.replace(\"-\", \"\").replace(\"_\", \"\").replace(\" \", \"\"), subnet_id=subnet_id))\n\n        vpc_subnets = ec2.SubnetSelection(subnets=subnets)\n\n\n        ##\n        ## Default Instance Type\n        ##\n        if not instance_type:\n            instance_type = ec2.InstanceType.of(ec2.InstanceClass.MEMORY4, ec2.InstanceSize.LARGE)\n\n        ##\n        ## Default Engine version\n        ## https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_rds/MysqlEngineVersion.html\n        ##\n        if not engine_version:\n            engine_version = rds.MysqlEngineVersion.VER_8_0_28\n\n        ##\n        ## MySQL Instance\n        ##\n        rds.DatabaseInstance(self, \"MySqlInstance\",\n            database_name=db_name,\n            engine=rds.DatabaseInstanceEngine.mysql(version=engine_version),\n            instance_type=instance_type,\n            vpc_subnets=vpc_subnets,\n            vpc=vpc,\n            port=3306,\n            removal_policy=RemovalPolicy.DESTROY,\n            deletion_protection=False\n        )", "language": "python"}
{"input": "CDK class FirehoseEnv for AWS resource management", "output": "class FirehoseEnv extends Stack {\n  constructor(scope: constructs.Construct, id: string) {\n    super(scope, id);\n\n    const bucket = new s3.Bucket(this, 'MyBucket', {\n      removalPolicy: RemovalPolicy.DESTROY,\n    });\n    const stream = new firehose.DeliveryStream(this, 'MyStream', {\n      destination: new firehose.S3Bucket(bucket, { loggingConfig: { logging: false } }),\n    });\n    const logGroup = new logs.LogGroup(this, 'LogGroup', {\n      removalPolicy: RemovalPolicy.DESTROY,\n    });\n    const firehoseDestination = new dests.FirehoseDestination(stream);\n\n    new logs.SubscriptionFilter(this, 'Subscription', {\n      logGroup: logGroup,\n      destination: firehoseDestination,\n      filterPattern: logs.FilterPattern.allEvents(),\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class Cluster for AWS resource management", "output": "export class Cluster extends ClusterBase {\n  /**\n   * Uniquely identifies this class.\n   */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-eks.Cluster';\n\n  /**\n   * Import an existing cluster\n   *\n   * @param scope the construct scope, in most cases 'this'\n   * @param id the id or name to import as\n   * @param attrs the cluster properties to use for importing information\n   */\n  public static fromClusterAttributes(scope: Construct, id: string, attrs: ClusterAttributes): ICluster {\n    return new ImportedCluster(scope, id, attrs);\n  }\n\n  private accessEntries: Map<string, IAccessEntry> = new Map();\n\n  /**\n   * The VPC in which this Cluster was created\n   */\n  public readonly vpc: ec2.IVpc;\n\n  /**\n   * The Name of the created EKS Cluster\n   */\n  public readonly clusterName: string;\n\n  /**\n   * The AWS generated ARN for the Cluster resource\n   *\n   * For example, `arn:aws:eks:us-west-2:666666666666:cluster/prod`\n   */\n  public readonly clusterArn: string;\n\n  /**\n   * The endpoint URL for the Cluster\n   *\n   * This is the URL inside the kubeconfig file to use with kubectl\n   *\n   * For example, `https://5E1D0CEXAMPLEA591B746AFC5AB30262.yl4.us-west-2.eks.amazonaws.com`\n   */\n  public readonly clusterEndpoint: string;\n\n  /**\n   * The certificate-authority-data for your cluster.\n   */\n  public readonly clusterCertificateAuthorityData: string;\n\n  /**\n   * The id of the cluster security group that was created by Amazon EKS for the cluster.\n   */\n  public readonly clusterSecurityGroupId: string;\n\n  /**\n   * The cluster security group that was created by Amazon EKS for the cluster.\n   */\n  public readonly clusterSecurityGroup: ec2.ISecurityGroup;\n\n  /**\n   * Amazon Resource Name (ARN) or alias of the customer master key (CMK).\n   */\n  public readonly clusterEncryptionConfigKeyArn: string;\n\n  /**\n   * Manages connection rules (Security Group Rules) for the cluster\n   *\n   * @type {ec2.Connections}\n   * @memberof Cluster\n   */\n  public readonly connections: ec2.Connections;\n\n  /**\n   * IAM role assumed by the EKS Control Plane\n   */\n  public readonly role: iam.IRole;\n\n  /**\n   * The auto scaling group that hosts the default capacity for this cluster.\n   * This will be `undefined` if the `defaultCapacityType` is not `EC2` or\n   * `defaultCapacityType` is `EC2` but default capacity is set to 0.\n   */\n  public readonly defaultCapacity?: autoscaling.AutoScalingGroup;\n\n  /**\n   * The node group that hosts the default capacity for this cluster.\n   * This will be `undefined` if the `defaultCapacityType` is `EC2` or\n   * `defaultCapacityType` is `NODEGROUP` but default capacity is set to 0.\n   */\n  public readonly defaultNodegroup?: Nodegroup;\n\n  /**\n   * An IAM role that can perform kubectl operations against this cluster.\n   *\n   * The role should be mapped to the `system:masters` Kubernetes RBAC role.\n   */\n  public readonly kubectlRole?: iam.IRole;\n\n  /**\n   * An IAM role that can perform kubectl operations against this cluster.\n   *\n   * The role should be mapped to the `system:masters` Kubernetes RBAC role.\n   *\n   * This role is directly passed to the lambda handler that sends Kube Ctl commands to the cluster.\n   * @default - if not specified, the default role created by a lambda function will\n   * be used.\n   */\n\n  public readonly kubectlLambdaRole?: iam.IRole;\n\n  /**\n   * Custom environment variables when running `kubectl` against this cluster.\n   */\n  public readonly kubectlEnvironment?: { [key: string]: string };\n\n  /**\n   * A security group to use for `kubectl` execution.\n   *\n   * @default - If not specified, the k8s endpoint is expected to be accessible\n   * publicly.\n   */\n  public readonly kubectlSecurityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * Subnets to host the `kubectl` compute resources.\n   *\n   * @default - If not specified, the k8s endpoint is expected to be accessible\n   * publicly.\n   */\n  public readonly kubectlPrivateSubnets?: ec2.ISubnet[];\n\n  /**\n   * Specify which IP family is used to assign Kubernetes pod and service IP addresses.\n   *\n   * @default - IpFamily.IP_V4\n   * @see https://docs.aws.amazon.com/eks/latest/APIReference/API_KubernetesNetworkConfigRequest.html#AmazonEKS-Type-KubernetesNetworkConfigRequest-ipFamily\n   */\n  public readonly ipFamily?: IpFamily;\n\n  /**\n   * An IAM role with administrative permissions to create or update the\n   * cluster. This role also has `systems:master` permissions.\n   */\n  public readonly adminRole: iam.Role;\n\n  /**\n   * If the cluster has one (or more) FargateProfiles associated, this array\n   * will hold a reference to each.\n   */\n  private readonly _fargateProfiles: FargateProfile[] = [];\n\n  /**\n   * an Open ID Connect Provider instance\n   */\n  private _openIdConnectProvider?: iam.IOpenIdConnectProvider;\n\n  /**\n   * an EKS Pod Identity Agent instance\n   */\n  private _eksPodIdentityAgent?: IAddon;\n\n  /**\n   * An AWS Lambda layer that includes `kubectl` and `helm`\n   *\n   */\n  readonly kubectlLayer?: lambda.ILayerVersion;\n\n  /**\n   * An AWS Lambda layer that contains the `aws` CLI.\n   *\n   * If not defined, a default layer will be used containing the AWS CLI 1.x.\n   */\n  readonly awscliLayer?: lambda.ILayerVersion;\n\n  /**\n   * The amount of memory allocated to the kubectl provider's lambda function.\n   */\n  public readonly kubectlMemory?: Size;\n\n  /**\n   * A security group to associate with the Cluster Handler's Lambdas.\n   * The Cluster Handler's Lambdas are responsible for calling AWS's EKS API.\n   *\n   * Requires `placeClusterHandlerInVpc` to be set to true.\n   *\n   * @default - No security group.\n   */\n  public readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * The AWS Lambda layer that contains the NPM dependency `proxy-agent`. If\n   * undefined, a SAR app that contains this layer will be used.\n   */\n  readonly onEventLayer?: lambda.ILayerVersion;\n\n  /**\n   * Determines if Kubernetes resources can be pruned automatically.\n   */\n  public readonly prune: boolean;\n\n  /**\n   * The ALB Controller construct defined for this cluster.\n   * Will be undefined if `albController` wasn't configured.\n   */\n  public readonly albController?: AlbController;\n\n  /**\n   * The authentication mode for the Amazon EKS cluster.\n   *\n   * The authentication mode determines how users and applications authenticate to the Kubernetes API server.\n   *\n   * @property {AuthenticationMode} [authenticationMode] - The authentication mode for the Amazon EKS cluster.\n   *\n   * @default CONFIG_MAP.\n   */\n  public readonly authenticationMode?: AuthenticationMode;\n\n  /**\n   * If this cluster is kubectl-enabled, returns the `ClusterResource` object\n   * that manages it. If this cluster is not kubectl-enabled (i.e. uses the\n   * stock `CfnCluster`), this is `undefined`.\n   */\n  private readonly _clusterResource: ClusterResource;\n\n  private _neuronDevicePlugin?: KubernetesManifest;\n\n  private readonly endpointAccess: EndpointAccess;\n\n  private readonly vpcSubnets: ec2.SubnetSelection[];\n\n  private readonly version: KubernetesVersion;\n\n  private readonly logging?: { [key: string]: [ { [key: string]: any } ] };\n\n  /**\n   * A dummy CloudFormation resource that is used as a wait barrier which\n   * represents that the cluster is ready to receive \"kubectl\" commands.\n   *\n   * Specifically, all fargate profiles are automatically added as a dependency\n   * of this barrier, which means that it will only be \"signaled\" when all\n   * fargate profiles have been successfully created.\n   *\n   * When kubectl resources call `_attachKubectlResourceScope()`, this resource\n   * is added as their dependency which implies that they can only be deployed\n   * after the cluster is ready.\n   */\n  private readonly _kubectlReadyBarrier: CfnResource;\n\n  private readonly _kubectlResourceProvider: KubectlProvider;\n\n  /**\n   * Initiates an EKS Cluster with the supplied arguments\n   *\n   * @param scope a Construct, most likely a cdk.Stack created\n   * @param id the id of the Construct to create\n   * @param props properties in the IClusterProps interface\n   */\n  constructor(scope: Construct, id: string, props: ClusterProps) {\n    super(scope, id, {\n      physicalName: props.clusterName,\n    });\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    const stack = Stack.of(this);\n\n    this.prune = props.prune ?? true;\n    this.vpc = props.vpc || new ec2.Vpc(this, 'DefaultVpc');\n\n    this.version = props.version;\n\n    // since this lambda role needs to be added to the trust policy of the creation role,\n    // we must create it in this scope (instead of the KubectlProvider nested stack) to avoid\n    // a circular dependency.\n    this.kubectlLambdaRole = props.kubectlLambdaRole ? props.kubectlLambdaRole : new iam.Role(this, 'KubectlHandlerRole', {\n      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n      managedPolicies: [iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')],\n    });\n\n    this.tagSubnets();\n\n    // this is the role used by EKS when interacting with AWS resources\n    this.role = props.role || new iam.Role(this, 'Role', {\n      assumedBy: new iam.ServicePrincipal('eks.amazonaws.com'),\n      managedPolicies: [\n        iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEKSClusterPolicy'),\n      ],\n    });\n\n    const securityGroup = props.securityGroup || new ec2.SecurityGroup(this, 'ControlPlaneSecurityGroup', {\n      vpc: this.vpc,\n      description: 'EKS Control Plane Security Group',\n    });\n\n    this.vpcSubnets = props.vpcSubnets ?? [{ subnetType: ec2.SubnetType.PUBLIC }, { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS }];\n\n    const selectedSubnetIdsPerGroup = this.vpcSubnets.map(s => this.vpc.selectSubnets(s).subnetIds);\n    if (selectedSubnetIdsPerGroup.some(Token.isUnresolved) && selectedSubnetIdsPerGroup.length > 1) {\n      throw new ValidationError('eks.Cluster: cannot select multiple subnet groups from a VPC imported from list tokens with unknown length. Select only one subnet group, pass a length to Fn.split, or switch to Vpc.fromLookup.', this);\n    }\n\n    // Get subnetIds for all selected subnets\n    const subnetIds = Array.from(new Set(flatten(selectedSubnetIdsPerGroup)));\n\n    this.logging = props.clusterLogging ? {\n      clusterLogging: [\n        {\n          enabled: true,\n          types: Object.values(props.clusterLogging),\n        },\n      ],\n    } : undefined;\n\n    this.endpointAccess = props.endpointAccess ?? EndpointAccess.PUBLIC_AND_PRIVATE;\n    this.kubectlEnvironment = props.kubectlEnvironment;\n    this.kubectlLayer = props.kubectlLayer;\n    this.awscliLayer = props.awscliLayer;\n    this.kubectlMemory = props.kubectlMemory;\n    this.ipFamily = props.ipFamily ?? IpFamily.IP_V4;\n    this.onEventLayer = props.onEventLayer;\n    this.clusterHandlerSecurityGroup = props.clusterHandlerSecurityGroup;\n\n    const privateSubnets = this.selectPrivateSubnets().slice(0, 16);\n    const publicAccessDisabled = !this.endpointAccess._config.publicAccess;\n    const publicAccessRestricted = !publicAccessDisabled\n      && this.endpointAccess._config.publicCidrs\n      && this.endpointAccess._config.publicCidrs.length !== 0;\n\n    // Check if any subnet selection is pending lookup\n    const hasPendingLookup = this.vpcSubnets.some(placement =>\n      this.vpc.selectSubnets(placement).isPendingLookup,\n    );\n\n    // validate endpoint access configuration\n    if (!hasPendingLookup) {\n      if (privateSubnets.length === 0 && publicAccessDisabled) {\n        // no private subnets and no public access at all, no good.\n        throw new ValidationError('Vpc must contain private subnets when public endpoint access is disabled', this);\n      }\n\n      if (privateSubnets.length === 0 && publicAccessRestricted) {\n      // no private subnets and public access is restricted, no good.\n        throw new ValidationError('Vpc must contain private subnets when public endpoint access is restricted', this);\n      }\n    }\n\n    const placeClusterHandlerInVpc = props.placeClusterHandlerInVpc ?? false;\n\n    if (!hasPendingLookup) {\n      if (placeClusterHandlerInVpc && privateSubnets.length === 0) {\n        throw new ValidationError('Cannot place cluster handler in the VPC since no private subnets could be selected', this);\n      }\n    }\n\n    if (props.clusterHandlerSecurityGroup && !placeClusterHandlerInVpc) {\n      throw new ValidationError('Cannot specify clusterHandlerSecurityGroup without placeClusterHandlerInVpc set to true', this);\n    }\n\n    if (props.serviceIpv4Cidr && props.ipFamily == IpFamily.IP_V6) {\n      throw new ValidationError('Cannot specify serviceIpv4Cidr with ipFamily equal to IpFamily.IP_V6', this);\n    }\n\n    // Check if the cluster name exceeds 100 characters\n    if (!Token.isUnresolved(this.physicalName) && this.physicalName.length > 100) {\n      throw new ValidationError('Cluster name cannot be more than 100 characters', this);\n    }\n\n    this.validateRemoteNetworkConfig(props);\n\n    this.authenticationMode = props.authenticationMode;\n\n    const resource = this._clusterResource = new ClusterResource(this, 'Resource', {\n      name: this.physicalName,\n      environment: props.clusterHandlerEnvironment,\n      roleArn: this.role.roleArn,\n      version: props.version.version,\n      accessconfig: {\n        authenticationMode: props.authenticationMode,\n        bootstrapClusterCreatorAdminPermissions: props.bootstrapClusterCreatorAdminPermissions,\n      },\n      ...(props.remoteNodeNetworks ? {\n        remoteNetworkConfig: {\n          remoteNodeNetworks: props.remoteNodeNetworks,\n          ...(props.remotePodNetworks ? {\n            remotePodNetworks: props.remotePodNetworks,\n          }: {}),\n        },\n      } : {}),\n      resourcesVpcConfig: {\n        securityGroupIds: [securityGroup.securityGroupId],\n        subnetIds,\n      },\n      ...(props.secretsEncryptionKey ? {\n        encryptionConfig: [{\n          provider: {\n            keyArn: props.secretsEncryptionKey.keyRef.keyArn,\n          },\n          resources: ['secrets'],\n        }],\n      } : {}),\n      kubernetesNetworkConfig: {\n        ipFamily: this.ipFamily,\n        serviceIpv4Cidr: props.serviceIpv4Cidr,\n      },\n      endpointPrivateAccess: this.endpointAccess._config.privateAccess,\n      endpointPublicAccess: this.endpointAccess._config.publicAccess,\n      publicAccessCidrs: this.endpointAccess._config.publicCidrs,\n      secretsEncryptionKey: props.secretsEncryptionKey,\n      vpc: this.vpc,\n      subnets: placeClusterHandlerInVpc ? privateSubnets : undefined,\n      clusterHandlerSecurityGroup: this.clusterHandlerSecurityGroup,\n      onEventLayer: this.onEventLayer,\n      tags: props.tags,\n      logging: this.logging,\n      bootstrapSelfManagedAddons: props.bootstrapSelfManagedAddons,\n    });\n\n    if (this.endpointAccess._config.privateAccess && privateSubnets.length !== 0) {\n      // when private access is enabled and the vpc has private subnets, lets connect\n      // the provider to the vpc so that it will work even when restricting public access.\n\n      // validate VPC properties according to: https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html\n      if (this.vpc instanceof ec2.Vpc && !(this.vpc.dnsHostnamesEnabled && this.vpc.dnsSupportEnabled)) {\n        throw new ValidationError('Private endpoint access requires the VPC to have DNS support and DNS hostnames enabled. Use `enableDnsHostnames: true` and `enableDnsSupport: true` when creating the VPC.', this);\n      }\n\n      this.kubectlPrivateSubnets = privateSubnets;\n\n      // the vpc must exist in order to properly delete the cluster (since we run `kubectl delete`).\n      // this ensures that.\n      this._clusterResource.node.addDependency(this.vpc);\n    }\n\n    this.adminRole = resource.adminRole;\n\n    // we use an SSM parameter as a barrier because it's free and fast.\n    this._kubectlReadyBarrier = new CfnResource(this, 'KubectlReadyBarrier', {\n      type: 'AWS::SSM::Parameter',\n      properties: {\n        Type: 'String',\n        Value: 'aws:cdk:eks:kubectl-ready',\n      },\n    });\n\n    // add the cluster resource itself as a dependency of the barrier\n    this._kubectlReadyBarrier.node.addDependency(this._clusterResource);\n\n    this.clusterName = this.getResourceNameAttribute(resource.ref);\n    this.clusterArn = this.getResourceArnAttribute(resource.attrArn, clusterArnComponents(this.physicalName));\n\n    this.clusterEndpoint = resource.attrEndpoint;\n    this.clusterCertificateAuthorityData = resource.attrCertificateAuthorityData;\n    this.clusterSecurityGroupId = resource.attrClusterSecurityGroupId;\n    this.clusterEncryptionConfigKeyArn = resource.attrEncryptionConfigKeyArn;\n\n    this.clusterSecurityGroup = ec2.SecurityGroup.fromSecurityGroupId(this, 'ClusterSecurityGroup', this.clusterSecurityGroupId);\n\n    this.connections = new ec2.Connections({\n      securityGroups: [this.clusterSecurityGroup, securityGroup],\n      defaultPort: ec2.Port.tcp(443), // Control Plane has an HTTPS API\n    });\n\n    // we can use the cluster security group since its already attached to the cluster\n    // and configured to allow connections from itself.\n    this.kubectlSecurityGroup = this.clusterSecurityGroup;\n\n    this.adminRole.assumeRolePolicy?.addStatements(new iam.PolicyStatement({\n      actions: ['sts:AssumeRole'],\n      principals: [this.kubectlLambdaRole],\n    }));\n\n    // use the cluster creation role to issue kubectl commands against the cluster because when the\n    // cluster is first created, that's the only role that has \"system:masters\" permissions\n    this.kubectlRole = this.adminRole;\n\n    this._kubectlResourceProvider = this.defineKubectlProvider();\n\n    const updateConfigCommandPrefix = `aws eks update-kubeconfig --name ${this.clusterName}`;\n    const getTokenCommandPrefix = `aws eks get-token --cluster-name ${this.clusterName}`;\n    const commonCommandOptions = [`--region ${stack.region}`];\n\n    if (props.outputClusterName) {\n      new CfnOutput(this, 'ClusterName', { value: this.clusterName });\n    }\n\n    const supportAuthenticationApi = (this.authenticationMode === AuthenticationMode.API ||\n      this.authenticationMode === AuthenticationMode.API_AND_CONFIG_MAP) ? true : false;\n\n    // do not create a masters role if one is not provided. Trusting the accountRootPrincipal() is too permissive.\n    if (props.mastersRole) {\n      const mastersRole = props.mastersRole;\n\n      // if we support authentication API we create an access entry for this mastersRole\n      // with cluster scope.\n      if (supportAuthenticationApi) {\n        this.grantAccess('mastersRoleAccess', props.mastersRole.roleArn, [\n          AccessPolicy.fromAccessPolicyName('AmazonEKSClusterAdminPolicy', {\n            accessScopeType: AccessScopeType.CLUSTER,\n          }),\n        ]);\n      } else {\n        // if we don't support authentication API we should fallback to configmap\n        // this would avoid breaking changes as well if authenticationMode is undefined\n        this.awsAuth.addMastersRole(mastersRole);\n      }", "language": "typescript"}
{"input": "Placeholders which can be used manifests These can occur both in the Asset Manifest as well as the general Cloud Assembly manifest.", "output": "export class EnvironmentPlaceholders {\n  /**\n   * Insert this into the destination fields to be replaced with the current region\n   */\n  public static readonly CURRENT_REGION = '${AWS::Region}';\n\n  /**\n   * Insert this into the destination fields to be replaced with the current account\n   */\n  public static readonly CURRENT_ACCOUNT = '${AWS::AccountId}';\n\n  /**\n   * Insert this into the destination fields to be replaced with the current partition\n   */\n  public static readonly CURRENT_PARTITION = '${AWS::Partition}';\n\n  /**\n   * Replace the environment placeholders in all strings found in a complex object.\n   *\n   * Duplicated between cdk-assets and aws-cdk CLI because we don't have a good single place to put it\n   * (they're nominally independent tools).\n   */\n  public static replace(object: any, values: EnvironmentPlaceholderValues): any {\n    return this.recurse(object, value => {\n      value = replaceAll(value, EnvironmentPlaceholders.CURRENT_REGION, values.region);\n      value = replaceAll(value, EnvironmentPlaceholders.CURRENT_ACCOUNT, values.accountId);\n      value = replaceAll(value, EnvironmentPlaceholders.CURRENT_PARTITION, values.partition);\n      return value;\n    });\n  }\n\n  /**\n   * Like 'replace', but asynchronous\n   */\n  public static async replaceAsync(object: any, provider: IEnvironmentPlaceholderProvider): Promise<any> {\n    let needRegion = false;\n    let needAccountId = false;\n    let needPartition = false;\n\n    this.recurse(object, value => {\n      if (value.indexOf(EnvironmentPlaceholders.CURRENT_REGION) > 1) { needRegion = true; }\n      if (value.indexOf(EnvironmentPlaceholders.CURRENT_ACCOUNT) > 1) { needAccountId = true; }\n      if (value.indexOf(EnvironmentPlaceholders.CURRENT_PARTITION) > 1) { needPartition = true; }\n      return value;\n    });\n\n    const region = needRegion ? await provider.region() : undefined;\n    const accountId = needAccountId ? await provider.accountId() : undefined;\n    const partition = needPartition ? await provider.partition() : undefined;\n\n    return this.recurse(object, value => {\n      value = replaceAll(value, EnvironmentPlaceholders.CURRENT_REGION, region ?? 'WONTHAPPEN');\n      value = replaceAll(value, EnvironmentPlaceholders.CURRENT_ACCOUNT, accountId ?? 'WONTHAPPEN');\n      value = replaceAll(value, EnvironmentPlaceholders.CURRENT_PARTITION, partition ?? 'WONTHAPPEN');\n      return value;\n    });\n  }\n\n  private static recurse(value: any, cb: (x: string) => string): any {\n    if (typeof value === 'string') { return cb(value); }\n    if (typeof value !== 'object' || value === null) { return value; }\n    if (Array.isArray(value)) { return value.map(x => this.recurse(x, cb)); }\n\n    const ret: Record<string, any> = {};\n    for (const [key, inner] of Object.entries(value)) {\n      ret[key] = this.recurse(inner, cb);\n    }\n    return ret;\n  }\n}", "language": "typescript"}
{"input": "Class which constructs the input from provided Application ARN.", "output": "class ExistingTargetApplication extends TargetApplication {\n  constructor(\n    private readonly applicationOptions: ExistingTargetApplicationOptions) {\n    super();\n  }\n  public bind(scope: Construct): BindTargetApplicationResult {\n    (this.applicationOptions.stackName as string) =\n      this.applicationOptions.stackName || `ApplicationAssociator-${hashValues(scope.node.addr)}-Stack`;\n    const stackId = this.applicationOptions.stackName;\n    const applicationStack = new cdk.Stack(scope, stackId, this.applicationOptions);\n    const appRegApplication = Application.fromApplicationArn(applicationStack, 'ExistingApplication', this.applicationOptions.applicationArnValue);\n    return {\n      application: appRegApplication,\n      associateCrossAccountStacks: this.applicationOptions.associateCrossAccountStacks ?? false,\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK class CompositeAlarmIntegrationTest for AWS resource management", "output": "class CompositeAlarmIntegrationTest extends Stack {\n  constructor(scope: App, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const testMetric = new Metric({\n      namespace: 'CDK/Test',\n      metricName: 'Metric',\n    });\n\n    const alarm1 = new Alarm(this, 'Alarm1', {\n      metric: testMetric,\n      threshold: 100,\n      evaluationPeriods: 3,\n    });\n\n    const alarm2 = new Alarm(this, 'Alarm2', {\n      metric: testMetric,\n      threshold: 1000,\n      evaluationPeriods: 3,\n    });\n\n    const alarm3 = new Alarm(this, 'Alarm3', {\n      metric: testMetric,\n      threshold: 10000,\n      evaluationPeriods: 3,\n    });\n\n    const alarm4 = new Alarm(this, 'Alarm4', {\n      metric: testMetric,\n      threshold: 100000,\n      evaluationPeriods: 3,\n    });\n\n    const alarm5 = new Alarm(this, 'Alarm5', {\n      alarmName: 'Alarm with space in name',\n      metric: testMetric,\n      threshold: 100000,\n      evaluationPeriods: 3,\n    });\n\n    const alarmRule = AlarmRule.anyOf(\n      AlarmRule.allOf(\n        AlarmRule.anyOf(\n          alarm1,\n          AlarmRule.fromAlarm(alarm2, AlarmState.OK),\n          alarm3,\n          alarm5,\n        ),\n        AlarmRule.not(AlarmRule.fromAlarm(alarm4, AlarmState.INSUFFICIENT_DATA)),\n      ),\n      AlarmRule.fromBoolean(false),\n    );\n\n    new CompositeAlarm(this, 'CompositeAlarm', {\n      alarmRule,\n      actionsSuppressor: alarm5,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates Lambda, DynamoDB, EC2 resources", "output": "class ApigwHttpApiLambdaDynamodbPythonCdkStack(Stack):\n    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:\n        super().__init__(scope, construct_id, **kwargs)\n\n        # VPC\n        vpc = ec2.Vpc(\n            self,\n            \"Ingress\",\n            cidr=\"10.1.0.0/16\",\n            subnet_configuration=[\n                ec2.SubnetConfiguration(\n                    name=\"Private-Subnet\", subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,\n                    cidr_mask=24\n                )\n            ],\n        )\n        \n        # Create VPC endpoint\n        dynamo_db_endpoint = ec2.GatewayVpcEndpoint(\n            self,\n            \"DynamoDBVpce\",\n            service=ec2.GatewayVpcEndpointAwsService.DYNAMODB,\n            vpc=vpc,\n        )\n\n        # This allows to customize the endpoint policy\n        dynamo_db_endpoint.add_to_policy(\n            iam.PolicyStatement(  # Restrict to listing and describing tables\n                principals=[iam.AnyPrincipal()],\n                actions=[                \"dynamodb:DescribeStream\",\n                \"dynamodb:DescribeTable\",\n                \"dynamodb:Get*\",\n                \"dynamodb:Query\",\n                \"dynamodb:Scan\",\n                \"dynamodb:CreateTable\",\n                \"dynamodb:Delete*\",\n                \"dynamodb:Update*\",\n                \"dynamodb:PutItem\"],\n                resources=[\"*\"],\n            )\n        )\n\n        # Create DynamoDb Table\n        demo_table = dynamodb_.Table(\n            self,\n            TABLE_NAME,\n            partition_key=dynamodb_.Attribute(\n                name=\"id\", type=dynamodb_.AttributeType.STRING\n            ),\n        )\n\n        # Create the Lambda function to receive the request\n        api_hanlder = lambda_.Function(\n            self,\n            \"ApiHandler\",\n            function_name=\"apigw_handler\",\n            runtime=lambda_.Runtime.PYTHON_3_9,\n            code=lambda_.Code.from_asset(\"lambda/apigw-handler\"),\n            handler=\"index.handler\",\n            vpc=vpc,\n            vpc_subnets=ec2.SubnetSelection(\n                subnet_type=ec2.SubnetType.PRIVATE_ISOLATED\n            ),\n            memory_size=1024,\n            timeout=Duration.minutes(5),\n        )\n\n        # grant permission to lambda to write to demo table\n        demo_table.grant_write_data(api_hanlder)\n        api_hanlder.add_environment(\"TABLE_NAME\", demo_table.table_name)\n\n        # Create API Gateway\n        apigw_.LambdaRestApi(\n            self,\n            \"Endpoint\",\n            handler=api_hanlder,\n        )", "language": "python"}
{"input": "CDK Construct for Lake Formation infrastructure components", "output": "class LevelTwoConstruct extends Construct {\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n    new core.CfnResource(this, 'Resource', {\n      type: 'Test::Resource::Fake',\n      properties: {\n        result: 'success',\n      },\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates Lambda, VPC, CloudFormation, Config resources", "output": "class TestStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    new lambda.NodejsFunction(this, 'ts-handler', {\n      entry: path.join(__dirname, 'integ-handlers/ts-handler.ts'),\n      runtime: STANDARD_NODEJS_RUNTIME,\n      bundling: {\n        minify: true,\n        sourceMap: true,\n        sourceMapMode: lambda.SourceMapMode.BOTH,\n      },\n    });\n\n    new lambda.NodejsFunction(this, 'ts-handler-log-level', {\n      entry: path.join(__dirname, 'integ-handlers/ts-handler.ts'),\n      runtime: STANDARD_NODEJS_RUNTIME,\n      bundling: {\n        minify: true,\n        sourceMap: true,\n        sourceMapMode: lambda.SourceMapMode.BOTH,\n        logLevel: lambda.LogLevel.VERBOSE,\n      },\n    });\n\n    new lambda.NodejsFunction(this, 'js-handler', {\n      entry: path.join(__dirname, 'integ-handlers/js-handler.js'),\n      runtime: STANDARD_NODEJS_RUNTIME,\n    });\n\n    new lambda.NodejsFunction(this, 'js-handler-bundling-path', {\n      entry: path.join(__dirname, 'integ-handlers/js-handler.js'),\n      bundling: {\n        inject: [path.join(__dirname, 'whitespace path/shim.js')],\n      },\n    });\n\n    new lambda.NodejsFunction(this, 'js-handler-tsconfig-path', {\n      entry: path.join(__dirname, 'integ-handlers/js-handler.js'),\n      bundling: {\n        tsconfig: path.join(__dirname, 'whitespace path/tsconfig.json'),\n      },\n    });\n\n    new lambda.NodejsFunction(this, 'ts-handler-metafile-path', {\n      entry: path.join(__dirname, 'integ-handlers/whitespace path/ts-handler.ts'),\n      bundling: {\n        metafile: true,\n      },\n    });\n\n    new lambda.NodejsFunction(this, 'ts-handler-vpc', {\n      entry: path.join(__dirname, 'integ-handlers/ts-handler.ts'),\n      runtime: STANDARD_NODEJS_RUNTIME,\n      vpc: new Vpc(this, 'Vpc', { restrictDefaultSecurityGroup: false }),\n    });\n\n    new lambda.NodejsFunction(this, 'ts-handler-custom-handler-no-dots', {\n      entry: path.join(__dirname, 'integ-handlers/ts-handler.ts'),\n      runtime: STANDARD_NODEJS_RUNTIME,\n      bundling: {\n        minify: true,\n        sourceMap: true,\n        sourceMapMode: lambda.SourceMapMode.BOTH,\n      },\n      handler: 'handler',\n    });\n\n    new lambda.NodejsFunction(this, 'ts-handler-custom-handler-dots', {\n      entry: path.join(__dirname, 'integ-handlers/ts-web-handler.ts'),\n      runtime: STANDARD_NODEJS_RUNTIME,\n      bundling: {\n        minify: true,\n        sourceMap: true,\n        sourceMapMode: lambda.SourceMapMode.BOTH,\n        commandHooks: {\n          beforeBundling: () => [],\n          beforeInstall: () => [],\n          afterBundling: (_inputDir, outputDir) => [\n            `${os.platform() === 'win32' ? 'copy' : 'cp'} ${path.join(\n              __dirname,\n              'integ-handlers',\n              'ts-web-run.sh',\n            )} ${outputDir}`,\n          ],\n        },\n      },\n      handler: 'ts-web.run.sh',\n      layers: [\n        LayerVersion.fromLayerVersionArn(\n          this,\n          'lambda-adapter-layer',\n          `arn:aws:lambda:${Aws.REGION}:753240598075:layer:LambdaAdapterLayerX86:13`,\n        ),\n      ],\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates CloudFormation, ECR resources", "output": "class TestStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const repository = new codecommit.Repository(this, 'Repo', {\n      repositoryName: 'integ-amplify-app',\n    });\n\n    const amplifyApp = new amplify.App(this, 'App', {\n      sourceCodeProvider: new amplify.CodeCommitSourceCodeProvider({ repository }),\n    });\n\n    amplifyApp.addBranch('main');\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates Lambda, KMS, Cognito, CloudFormation resources", "output": "class TestStack extends Stack {\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    const zone = new route53.PublicHostedZone(this, 'HostedZone', { zoneName: 'test.public' });\n    const userPool = new UserPool(this, 'UserPool');\n    const domain = new UserPoolDomain(this, 'UserPoolDomain', {\n      userPool,\n      cognitoDomain: { domainPrefix: 'domain-prefix' },\n    });\n\n    new route53.ARecord(zone, 'Alias', {\n      zone,\n      target: route53.RecordTarget.fromAlias(new targets.UserPoolDomainTarget(domain)),\n    });\n  }\n}", "language": "typescript"}
{"input": "S3 bucket definition for a CodeBuild project.", "output": "class S3Source extends Source {\n  public readonly type = S3_SOURCE_TYPE;\n  private readonly bucket: s3.IBucket;\n  private readonly path: string;\n  private readonly version?: string;\n\n  constructor(props: S3SourceProps) {\n    super(props);\n    this.bucket = props.bucket;\n    this.path = props.path;\n    this.version = props.version;\n  }\n\n  public bind(_scope: Construct, project: IProject): SourceConfig {\n    this.bucket.grantRead(project, this.path);\n\n    const superConfig = super.bind(_scope, project);\n    return {\n      sourceProperty: {\n        ...superConfig.sourceProperty,\n        location: `${this.bucket.bucketName}/${this.path}`,\n      },\n      sourceVersion: this.version,\n    };\n  }\n}", "language": "typescript"}
{"input": "Abstract AppSync datasource implementation. Do not use directly but use subclasses for concrete datasources", "output": "class BaseDataSource extends Construct {\n  /**\n   * the name of the data source\n   */\n  public readonly name: string;\n  /**\n   * the underlying CFN data source resource\n   */\n  public readonly ds: CfnDataSource;\n\n  private _api: IGraphQLApiRef;\n  protected serviceRole?: IRole;\n\n  constructor(scope: Construct, id: string, props: BackedDataSourceProps, extended: ExtendedDataSourceProps) {\n    super(scope, id);\n\n    if (extended.type !== 'NONE') {\n      this.serviceRole = props.serviceRole || new Role(this, 'ServiceRole', { assumedBy: new ServicePrincipal('appsync.amazonaws.com') });\n    }\n    // Replace unsupported characters from DataSource name. The only allowed pattern is: {[_A-Za-z][_0-9A-Za-z]*}\n    const name = (props.name ?? id);\n    const supportedName = Token.isUnresolved(name) ? name : name.replace(/[\\W]+/g, '');\n    const apiId = extractApiIdFromGraphQLApiRef(props.api);\n    this.ds = new CfnDataSource(this, 'Resource', {\n      apiId: apiId,\n      name: supportedName,\n      description: props.description,\n      serviceRoleArn: this.serviceRole?.roleArn,\n      ...extended,\n    });\n    this.name = supportedName;\n    this._api = props.api;\n  }\n\n  /**\n   * The API this data source is attached to\n   */\n  protected get api(): IGraphqlApi {\n    return toIGraphqlApi(this._api);\n  }\n\n  /**\n   * Set the API this data source is attached to\n   */\n  protected set api(api: IGraphqlApi) {\n    this._api = api;\n  }\n\n  /**\n   * creates a new resolver for this datasource and API using the given properties\n   */\n  public createResolver(id: string, props: BaseResolverProps): Resolver {\n    return new Resolver(this.api, id, {\n      api: this.api,\n      dataSource: this,\n      ...props,\n    });\n  }\n\n  /**\n   * creates a new appsync function for this datasource and API using the given properties\n   */\n  public createFunction(id: string, props: BaseAppsyncFunctionProps): AppsyncFunction {\n    return new AppsyncFunction(this.api, id, {\n      api: this.api,\n      dataSource: this,\n      ...props,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates S3, Lambda, DynamoDB, CloudFormation resources", "output": "class TestStack extends Stack {\n  public constructor(scope: Construct, id: string, props: StackProps) {\n    super(scope, id, props);\n\n    const lambdaFunction = new Function(this, 'Function', {\n      functionName: 'global-table-lambda',\n      runtime: Runtime.PYTHON_3_11,\n      code: Code.fromAsset(path.join(__dirname, 'replica-handler')),\n      handler: 'index.handler',\n    });\n\n    const globalTable = new TableV2(this, 'GlobalTable', {\n      tableName: 'global-table',\n      removalPolicy: RemovalPolicy.DESTROY,\n      partitionKey: { name: 'pk', type: AttributeType.STRING },\n      replicas: [\n        { region: 'us-west-1' },\n        { region: 'us-east-2' },\n      ],\n    });\n\n    globalTable.replica('us-west-1').grantWriteData(lambdaFunction);\n  }\n}", "language": "typescript"}
{"input": "A table in a Redshift cluster.", "output": "export class Table extends TableBase {\n  /**\n   * Specify a Redshift table using a table name and schema that already exists.\n   */\n  static fromTableAttributes(scope: Construct, id: string, attrs: TableAttributes): ITable {\n    return new class extends TableBase {\n      readonly tableName = attrs.tableName;\n      readonly tableColumns = attrs.tableColumns;\n      readonly cluster = attrs.cluster;\n      readonly databaseName = attrs.databaseName;\n    }(scope, id);\n  }\n\n  readonly tableName: string;\n  readonly tableColumns: Column[];\n  readonly cluster: ICluster;\n  readonly databaseName: string;\n\n  private resource: DatabaseQuery<TableHandlerProps>;\n\n  constructor(scope: Construct, id: string, props: TableProps) {\n    super(scope, id);\n\n    this.validateDistKeyColumns(props.tableColumns);\n    if (props.distStyle) {\n      this.validateDistStyle(props.distStyle, props.tableColumns);\n    }\n    if (props.sortStyle) {\n      this.validateSortStyle(props.sortStyle, props.tableColumns);\n    }\n\n    this.tableColumns = this.configureTableColumns(props.tableColumns);\n    this.cluster = props.cluster;\n    this.databaseName = props.databaseName;\n\n    const useColumnIds = !!cdk.FeatureFlags.of(this).isEnabled(REDSHIFT_COLUMN_ID);\n\n    this.resource = new DatabaseQuery<TableHandlerProps>(this, 'Resource', {\n      removalPolicy: cdk.RemovalPolicy.RETAIN,\n      ...props,\n      handler: HandlerName.Table,\n      properties: {\n        tableName: {\n          prefix: props.tableName ?? cdk.Names.uniqueId(this),\n          generateSuffix: (props.tableName == null).toString(),\n        },\n        tableColumns: this.tableColumns,\n        distStyle: props.distStyle,\n        sortStyle: props.sortStyle ?? this.getDefaultSortStyle(props.tableColumns),\n        tableComment: props.tableComment,\n        useColumnIds,\n      },\n    });\n\n    this.tableName = props.tableName ?? this.resource.ref;\n  }\n\n  /**\n   * Apply the given removal policy to this resource\n   *\n   * The Removal Policy controls what happens to this resource when it stops\n   * being managed by CloudFormation, either because you've removed it from the\n   * CDK application or because you've made a change that requires the resource\n   * to be replaced.\n   *\n   * The resource can be destroyed (`RemovalPolicy.DESTROY`), or left in your AWS\n   * account for data recovery and cleanup later (`RemovalPolicy.RETAIN`).\n   *\n   * This resource is retained by default.\n   */\n  public applyRemovalPolicy(policy: cdk.RemovalPolicy): void {\n    this.resource.applyRemovalPolicy(policy);\n  }\n\n  private validateDistKeyColumns(columns: Column[]): void {\n    try {\n      getDistKeyColumn(columns);\n    } catch {\n      throw new cdk.ValidationError('Only one column can be configured as distKey.', this);\n    }\n  }\n\n  private validateDistStyle(distStyle: TableDistStyle, columns: Column[]): void {\n    const distKeyColumn = getDistKeyColumn(columns);\n    if (distKeyColumn && distStyle !== TableDistStyle.KEY) {\n      throw new cdk.ValidationError(`Only 'TableDistStyle.KEY' can be configured when distKey is also configured. Found ${distStyle}`, this);\n    }\n    if (!distKeyColumn && distStyle === TableDistStyle.KEY) {\n      throw new cdk.ValidationError('distStyle of \"TableDistStyle.KEY\" can only be configured when distKey is also configured.', this);\n    }\n  }\n\n  private validateSortStyle(sortStyle: TableSortStyle, columns: Column[]): void {\n    const sortKeyColumns = getSortKeyColumns(columns);\n    if (sortKeyColumns.length === 0 && sortStyle !== TableSortStyle.AUTO) {\n      throw new cdk.ValidationError(`sortStyle of '${sortStyle}' can only be configured when sortKey is also configured.`, this);\n    }\n    if (sortKeyColumns.length > 0 && sortStyle === TableSortStyle.AUTO) {\n      throw new cdk.ValidationError(`sortStyle of '${TableSortStyle.AUTO}' cannot be configured when sortKey is also configured.`, this);\n    }\n  }\n\n  private getDefaultSortStyle(columns: Column[]): TableSortStyle {\n    const sortKeyColumns = getSortKeyColumns(columns);\n    return (sortKeyColumns.length === 0) ? TableSortStyle.AUTO : TableSortStyle.COMPOUND;\n  }\n\n  private configureTableColumns(columns: Column[]): Column[] {\n    const newColumns = [...columns];\n    const columnIds = new Set<string>();\n    for (let i = 0; i < columns.length; i++) {\n      const column = newColumns[i];\n      if (column.id) {\n        if (columnIds.has(column.id)) {\n          throw new cdk.ValidationError(`Column id '${column.id}' is not unique.`, this);\n        }\n        columnIds.add(column.id);\n      } else {\n        if (columnIds.has(column.name)) {\n          throw new cdk.ValidationError(`Column name '${column.name}' is not unique amongst the column ids.`, this);\n        }\n        newColumns[i] = { ...column, id: column.name };\n        columnIds.add(column.name);\n      }\n    }\n    return newColumns;\n  }\n}", "language": "typescript"}
{"input": "Properties of a DataQualityTargetTable.", "output": "export class DataQualityTargetTable {\n  /**\n   * The database name of the target table.\n   */\n  readonly databaseName: string;\n\n  /**\n   * The table name of the target table.\n   */\n  readonly tableName: string;\n\n  constructor(databaseName: string, tableName: string) {\n    this.databaseName = databaseName;\n    this.tableName = tableName;\n  }\n}", "language": "typescript"}
{"input": "Task extending sfn.TaskStateBase to facilitate integ testing setting credentials", "output": "export class FakeTask extends sfn.TaskStateBase {\n  protected readonly taskMetrics?: sfn.TaskMetricsConfig;\n  protected readonly taskPolicies?: iam.PolicyStatement[];\n  protected readonly parameters?: { [key: string]: string };\n\n  constructor(scope: constructs.Construct, id: string, props: FakeTaskProps = {}) {\n    super(scope, id, props);\n    this.parameters = props.parameters;\n  }\n\n  protected _renderTask(): any {\n    return {\n      Type: 'Task',\n      Resource: 'arn:aws:states:::dynamodb:putItem',\n      Parameters: {\n        TableName: 'my-cool-table',\n        Item: {\n          id: {\n            S: 'my-entry',\n          },\n        },\n        ...this.parameters,\n      },\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK class MatchmakingRuleSet for AWS resource management", "output": "export class MatchmakingRuleSet extends MatchmakingRuleSetBase {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = '@aws-cdk.aws-gamelift-alpha.MatchmakingRuleSet';\n\n  /**\n   * Import a ruleSet into CDK using its name\n   */\n  static fromMatchmakingRuleSetName(scope: Construct, id: string, matchmakingRuleSetName: string): IMatchmakingRuleSet {\n    return this.fromMatchmakingRuleSetAttributes(scope, id, { matchmakingRuleSetName });\n  }\n\n  /**\n   * Import a ruleSet into CDK using its ARN\n   */\n  static fromMatchmakingRuleSetArn(scope: Construct, id: string, matchmakingRuleSetArn: string): IMatchmakingRuleSet {\n    return this.fromMatchmakingRuleSetAttributes(scope, id, { matchmakingRuleSetArn });\n  }\n\n  /**\n   * Import an existing matchmaking ruleSet from its attributes.\n   */\n  static fromMatchmakingRuleSetAttributes(scope: Construct, id: string, attrs: MatchmakingRuleSetAttributes): IMatchmakingRuleSet {\n    if (!attrs.matchmakingRuleSetName && !attrs.matchmakingRuleSetArn) {\n      throw new Error('Either matchmakingRuleSetName or matchmakingRuleSetArn must be provided in MatchmakingRuleSetAttributes');\n    }\n    const matchmakingRuleSetName = attrs.matchmakingRuleSetName ??\n      cdk.Stack.of(scope).splitArn(attrs.matchmakingRuleSetArn!, cdk.ArnFormat.SLASH_RESOURCE_NAME).resourceName;\n\n    if (!matchmakingRuleSetName) {\n      throw new Error(`No matchmaking ruleSet identifier found in ARN: '${attrs.matchmakingRuleSetArn}'`);\n    }\n\n    const matchmakingRuleSetArn = attrs.matchmakingRuleSetArn ?? cdk.Stack.of(scope).formatArn({\n      service: 'gamelift',\n      resource: 'matchmakingruleset',\n      resourceName: attrs.matchmakingRuleSetName,\n      arnFormat: cdk.ArnFormat.SLASH_RESOURCE_NAME,\n    });\n    class Import extends MatchmakingRuleSetBase {\n      public readonly matchmakingRuleSetName = matchmakingRuleSetName!;\n      public readonly matchmakingRuleSetArn = matchmakingRuleSetArn;\n\n      constructor(s: Construct, i: string) {\n        super(s, i, {\n          environmentFromArn: matchmakingRuleSetArn,\n        });\n      }\n    }\n    return new Import(scope, id);\n  }\n\n  /**\n   * The unique name of the ruleSet.\n   */\n  public readonly matchmakingRuleSetName: string;\n\n  /**\n   * The ARN of the ruleSet.\n   */\n  public readonly matchmakingRuleSetArn: string;\n\n  constructor(scope: Construct, id: string, props: MatchmakingRuleSetProps) {\n    super(scope, id, {\n      physicalName: props.matchmakingRuleSetName,\n    });\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    if (!cdk.Token.isUnresolved(props.matchmakingRuleSetName)) {\n      if (props.matchmakingRuleSetName.length > 128) {\n        throw new Error(`RuleSet name can not be longer than 128 characters but has ${props.matchmakingRuleSetName.length} characters.`);\n      }\n\n      if (!/^[a-zA-Z0-9-\\.]+$/.test(props.matchmakingRuleSetName)) {\n        throw new Error(`RuleSet name ${props.matchmakingRuleSetName} can contain only letters, numbers, hyphens, back slash or dot with no spaces.`);\n      }\n    }\n    const content = props.content.bind(this);\n\n    const resource = new CfnMatchmakingRuleSet(this, 'Resource', {\n      name: props.matchmakingRuleSetName,\n      ruleSetBody: content.ruleSetBody,\n    });\n\n    this.matchmakingRuleSetName = this.getResourceNameAttribute(resource.ref);\n    this.matchmakingRuleSetArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'gamelift',\n      resource: 'matchmakingruleset',\n      resourceName: this.physicalName,\n      arnFormat: cdk.ArnFormat.SLASH_RESOURCE_NAME,\n    });\n  }\n}", "language": "typescript"}
{"input": "Function to create Datasync Task", "output": "def create_datasync_s3_task(self, s3_src_location, s3_dest_location):\n        task = datasync.CfnTask(\n            self,\n            'DataSyncS3toS3Task',\n            destination_location_arn=s3_src_location.attr_location_arn,\n            source_location_arn=s3_dest_location.attr_location_arn)\n        \n        CfnOutput(self, 'task_arn', value=task.attr_task_arn)\n    \n        return task", "language": "python"}
{"input": "CDK class ProfilerGroupIntegrationTest for AWS resource management", "output": "class ProfilerGroupIntegrationTest extends Stack {\n  constructor(scope: App, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const profilingGroup = new ProfilingGroup(this, 'MyProfilingGroup');\n\n    const publishAppRole = new Role(this, 'PublishAppRole', {\n      assumedBy: new AccountRootPrincipal(),\n    });\n    profilingGroup.grantPublish(publishAppRole);\n\n    const readAppRole = new Role(this, 'ReadAppRole', {\n      assumedBy: new AccountRootPrincipal(),\n    });\n    profilingGroup.grantRead(readAppRole);\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates S3, CloudFormation, Config resources", "output": "class DeploymentNestedStack extends NestedStack {\n  bucket: Bucket;\n  constructor (scope: Construct, id: string, props: DeploymentNestedStackProps) {\n    super(scope, id, props);\n    this.bucket = new Bucket(this, 'Bucket');\n    new BucketDeployment(this, 'DeployWithCrossNestedStackSource', {\n      destinationBucket: this.bucket,\n      sources: [\n        Source.jsonData('appconfig.json', { userPoolId: props.userPool.userPoolId }),\n      ],\n    });\n  }\n}", "language": "typescript"}
{"input": "Represents a new One Zone file system used as the destination file system for ReplicationConfiguration.", "output": "class OneZoneFileSystem extends ReplicationConfiguration {\n  constructor(props: OneZoneFileSystemProps) {\n    super(props);\n  }\n}", "language": "typescript"}
{"input": "CDK class CloudWatchLogsDestination for AWS resource management", "output": "class CloudWatchLogsDestination extends FlowLogDestination {\n  constructor(private readonly props: FlowLogDestinationConfig) {\n    super();\n  }\n\n  public bind(scope: Construct, _flowLog: FlowLog): FlowLogDestinationConfig {\n    let iamRole: iam.IRole;\n    let logGroup: logs.ILogGroupRef;\n    if (this.props.iamRole === undefined) {\n      iamRole = new iam.Role(scope, 'IAMRole', {\n        roleName: PhysicalName.GENERATE_IF_NEEDED,\n        assumedBy: new iam.ServicePrincipal('vpc-flow-logs.amazonaws.com'),\n      });\n    } else {\n      iamRole = this.props.iamRole;\n    }\n\n    if (this.props.logGroup === undefined) {\n      logGroup = new logs.LogGroup(scope, 'LogGroup');\n    } else {\n      logGroup = this.props.logGroup;\n    }\n\n    iamRole.addToPrincipalPolicy(\n      new iam.PolicyStatement({\n        actions: [\n          'logs:CreateLogStream',\n          'logs:PutLogEvents',\n          'logs:DescribeLogStreams',\n        ],\n        effect: iam.Effect.ALLOW,\n        resources: [logGroup.logGroupRef.logGroupArn],\n      }),\n    );\n\n    return {\n      logDestinationType: FlowLogDestinationType.CLOUD_WATCH_LOGS,\n      logGroup,\n      iamRole,\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates S3, CloudFormation resources", "output": "class S3Stack extends Stack {\n  public readonly bucket: Bucket;\n\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    this.bucket = new Bucket(this, 'Bucket', {\n      removalPolicy: RemovalPolicy.DESTROY,\n      autoDeleteObjects: true,\n    });\n\n    new BucketDeployment(this, 'BucketDeployment', {\n      destinationBucket: this.bucket,\n      sources: [\n        Source.jsonData('dynamodb-json-format.json', {\n          Item: {\n            id: {\n              S: '1',\n            },\n          },\n        }),\n        Source.data('ion-format.ion', `$ion_1_0 {\n            Item:{\n                id:\"1\",\n            }\n        }`),\n        Source.data('csv-format.csv', 'id\\n1'),\n      ],\n    });\n  }\n}", "language": "typescript"}
{"input": "Machine image representing the latest NAT instance image", "output": "export class NatInstanceImage extends LookupMachineImage {\n  constructor() {\n    super({\n      name: 'amzn-ami-vpc-nat-*',\n      owners: ['amazon'],\n    });\n  }\n}", "language": "typescript"}
{"input": "An image hosted in a public or private repository. For images hosted in Amazon ECR, see [EcrImage](https://docs.aws.amazon.com/AmazonECR/latest/userguide/images.html).", "output": "export class RepositoryImage extends ContainerImage {\n  /**\n   * Constructs a new instance of the RepositoryImage class.\n   */\n  constructor(private readonly imageName: string, private readonly props: RepositoryImageProps = {}) {\n    super();\n  }\n\n  public bind(scope: Construct, containerDefinition: ContainerDefinition): ContainerImageConfig {\n    // name could be a Token - in that case, skip validation altogether\n    if (!Token.isUnresolved(this.imageName) && ECR_IMAGE_REGEX.test(this.imageName)) {\n      Annotations.of(scope).addWarningV2('@aws-cdk/aws-ecs:ecrImageRequiresPolicy', \"Proper policies need to be attached before pulling from ECR repository, or use 'fromEcrRepository'.\");\n    }\n\n    if (this.props.credentials) {\n      this.props.credentials.grantRead(containerDefinition.taskDefinition.obtainExecutionRole());\n    }\n\n    return {\n      imageName: this.imageName,\n      repositoryCredentials: this.props.credentials && {\n        credentialsParameter: this.props.credentials.secretArn,\n      },\n    };\n  }\n}", "language": "typescript"}
{"input": "Represents the concept of an API Schema for a Bedrock Agent Action Group.", "output": "class ApiSchema extends ActionGroupSchema {\n  /**\n   * Creates an API Schema from a local file.\n   * @param path - the path to the local file containing the OpenAPI schema for the action group\n   */\n  public static fromLocalAsset(path: string): AssetApiSchema {\n    return new AssetApiSchema(path);\n  }\n\n  /**\n   * Creates an API Schema from an inline string.\n   * @param schema - the JSON or YAML payload defining the OpenAPI schema for the action group\n   */\n  public static fromInline(schema: string): InlineApiSchema {\n    return new InlineApiSchema(schema);\n  }\n\n  /**\n   * Creates an API Schema from an S3 File\n   * @param bucket - the bucket containing the local file containing the OpenAPI schema for the action group\n   * @param objectKey - object key in the bucket\n   */\n  public static fromS3File(bucket: IBucketRef, objectKey: string): S3ApiSchema {\n    return new S3ApiSchema({\n      bucketName: bucket.bucketRef.bucketName,\n      objectKey: objectKey,\n    });\n  }\n\n  /**\n   * The S3 location of the API schema file, if using an S3-based schema.\n   * Contains the bucket name and object key information.\n   */\n  public readonly s3File?: Location;\n\n  /**\n   * The inline OpenAPI schema definition as a string, if using an inline schema.\n   * Can be in JSON or YAML format.\n   */\n  public readonly inlineSchema?: string;\n\n  protected constructor(s3File?: Location, inlineSchema?: string) {\n    super();\n    this.s3File = s3File;\n    this.inlineSchema = inlineSchema;\n  }\n\n  /**\n   * Format as CFN properties\n   *\n   * @internal This is an internal core function and should not be called directly.\n   */\n  public abstract _render(): CfnAgent.APISchemaProperty;\n}", "language": "typescript"}
{"input": "Types of PII specific to the USA.", "output": "export class USASpecificPIIType extends PIIType {\n  /**\n   * A US bank account number, which is typically 10 to 12 digits long.\n   */\n  public static readonly US_BANK_ACCOUNT_NUMBER = new USASpecificPIIType('US_BANK_ACCOUNT_NUMBER');\n  /**\n   * A US bank account routing number. These are typically nine digits long.\n   */\n  public static readonly US_BANK_ROUTING_NUMBER = new USASpecificPIIType('US_BANK_ROUTING_NUMBER');\n  /**\n   * A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number\n   * that starts with a \"9\" and contain a \"7\" or \"8\" as the fourth digit.\n   */\n  public static readonly US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER = new USASpecificPIIType('US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER');\n  /**\n   * A US passport number. Passport numbers range from six to nine alphanumeric characters.\n   */\n  public static readonly US_PASSPORT_NUMBER = new USASpecificPIIType('US_PASSPORT_NUMBER');\n  /**\n   * A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens,\n   * permanent residents, and temporary working residents.\n   */\n  public static readonly US_SOCIAL_SECURITY_NUMBER = new USASpecificPIIType('US_SOCIAL_SECURITY_NUMBER');\n\n  private constructor(value: string) { super(value); }\n}", "language": "typescript"}
{"input": "CDK Stack that creates EC2, IAM, CloudFormation, CodeDeploy resources", "output": "export class CdkStack extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    //objects for access parameters\n    const node = this.node;\n\n    const appName = 'MyApp';\n    const platform = node.tryGetContext(\"platform\");\n    const solution = node.tryGetContext(\"solution\");\n\n\n    // Create Role: \n    const ebRole = new Role(this, `${appName}-eb-role` , {\n      assumedBy: new ServicePrincipal('ec2.amazonaws.com'),\n      roleName:`${appName}-eb-role`\n    });\n  \n    // some managed policies eb must have\n    ebRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AWSElasticBeanstalkWebTier'));\n    ebRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AWSElasticBeanstalkMulticontainerDocker'));\n    ebRole.addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName('AWSElasticBeanstalkWorkerTier'));\n\n    //Custom policies\n    //access to config secrets\n  \n    const roleARN = ebRole.roleArn;\n\n   // Create instance profile\n    const instanceProfile = new InstanceProfile(this, `${appName}-instance-role`, {\n      role: ebRole,\n      instanceProfileName: `${appName}-instance-role`,\n    })\n\n    const app = new CfnApplication(this, `${appName}-Application`, {\n      applicationName: appName\n    });\n\n    const env = new CfnEnvironment(this, `${appName}-Environment`, {\n      environmentName: `${appName}-Environment`,\n      applicationName: appName,\n      solutionStackName: solution,\n      //platformArn: platform,\n      optionSettings: [\n        {\n          namespace: \"aws:autoscaling:launchconfiguration\",\n          optionName: \"IamInstanceProfile\",\n          value: instanceProfile.instanceProfileArn,\n        },\n        {\n          namespace: \"aws:elasticbeanstalk:environment\",\n          optionName: \"EnvironmentType\",\n          value: \"SingleInstance\", \n        },\n      ]\n    });\n\n    // to ensure the application is created before the environment\n    env.addDependency(app);\n  }\n}", "language": "typescript"}
{"input": "CDK class AppRegistrySampleStage for AWS resource management", "output": "class AppRegistrySampleStage extends cdk.Stage {\n  public constructor(scope: Construct, id: string, props?: cdk.StageProps) {\n    super(scope, id, props);\n    new AppRegistrySampleStack(this, 'SampleStack', {});\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates Lambda, IAM, CloudFormation, CodeBuild resources", "output": "export class EvidentlyClientSideEvaluationLambdaStack extends cdk.Stack {\n  constructor(app: cdk.App, id: string) {\n    super(app, id);\n\n    // Create AppConfig resources\n    const application = new appconfig.CfnApplication(this,'AppConfigApplication', {\n      name: 'EvidentlyExampleProject'\n    });\n\n    const environment = new appconfig.CfnEnvironment(this, 'AppConfigEnvironment', {\n      applicationId: application.ref,\n      name: application.name + 'Environment'\n    });\n\n    // Create Evidently resources\n    const project = new evidently.CfnProject(this, 'EvidentlyProject', {\n      name: application.name,\n      appConfigResource: {\n        applicationId: application.ref,\n        environmentId: environment.ref\n      }\n    });\n\n    const feature = new evidently.CfnFeature(this, 'EvidentlyFeature', {\n      project: project.name,\n      name: 'MyExampleFeature',\n      variations: [\n        {\n          booleanValue: false,\n          variationName: HIDE_FEATURE\n        },\n        {\n          booleanValue: true,\n          variationName: SHOW_FEATURE\n        }\n      ]\n    })\n    feature.addDependsOn(project)\n\n    const launch = new evidently.CfnLaunch(this, 'EvidentlyLaunch', {\n      project: project.name,\n      name: 'ExampleFeatureLaunch',\n      executionStatus: {\n        status: 'START'\n      },\n      groups: [\n        {\n          feature: feature.name,\n          variation: HIDE_FEATURE,\n          groupName: HIDE_FEATURE\n        },\n        {\n          feature: feature.name,\n          variation: SHOW_FEATURE,\n          groupName: SHOW_FEATURE\n        }\n      ],\n      scheduledSplitsConfig: [{\n        // This must be a timestamp. Choosing a start time in the past with status START will start the launch immediately:\n        // https://docs.aws.amazon.com/cloudwatchevidently/latest/APIReference/API_ScheduledSplitConfig.html#cloudwatchevidently-Type-ScheduledSplitConfig-startTime\n        startTime: '2022-01-01T00:00:00Z',\n        groupWeights: [\n          {\n            groupName: HIDE_FEATURE,\n            splitWeight: 90000\n          },\n          {\n            groupName: SHOW_FEATURE,\n            splitWeight: 10000\n          }\n        ]\n      }]\n    })\n    launch.addDependsOn(feature)\n\n    // Create Lambda resources\n    const configuration = `applications/${application.ref}/environments/${environment.ref}/configurations/${project.name}`\n    const lambdaFunction = new lambda.Function(this, 'LambdaFunction', {\n      code: new lambda.InlineCode(fs.readFileSync('lambda-handler.py', { encoding: 'utf-8' })),\n      handler: 'index.main',\n      timeout: cdk.Duration.seconds(300),\n      runtime: lambda.Runtime.PYTHON_3_9,\n      layers: [\n        lambda.LayerVersion.fromLayerVersionArn(this, 'ClientSideEvaluationLayer', APP_CONFIG_EXTENSION_ARNS[AWS_REGION])\n      ],\n      environment: {\n        // This tells the AppConfig extension which AppConfig configuration to use for local evaluation.\n        // It must be in the form applications/<APP_ID>/environments/<ENV_ID>/configurations/<PROJECT_NAME>\n        AWS_APPCONFIG_EXTENSION_EVIDENTLY_CONFIGURATIONS: configuration,\n        AWS_APPCONFIG_EXTENSION_PREFETCH_LIST: configuration\n      }\n    });\n    lambdaFunction.role?.addToPrincipalPolicy(\n      new iam.PolicyStatement({\n        actions: ['appconfig:StartConfigurationSession', 'appconfig:GetLatestConfiguration'],\n        effect: iam.Effect.ALLOW,\n        resources: [`arn:aws:appconfig:${AWS_REGION}:${AWS_ACCOUNT}:application/${application.ref}/environment/${environment.ref}/configuration/*`]\n      })\n    )\n    lambdaFunction.role?.addToPrincipalPolicy(\n      new iam.PolicyStatement({\n        actions: ['evidently:PutProjectEvents'],\n        effect: iam.Effect.ALLOW,\n        resources: [`arn:aws:evidently:${AWS_REGION}:${AWS_ACCOUNT}:project/${project.name}`]\n      })\n    )\n\n  }\n}", "language": "typescript"}
{"input": "Elasticsearch version", "output": "export class ElasticsearchVersion {\n  /**\n   * AWS Elasticsearch 1.5\n   */\n  public static readonly V1_5 = ElasticsearchVersion.of('1.5');\n\n  /**\n   * AWS Elasticsearch 2.3\n   */\n  public static readonly V2_3 = ElasticsearchVersion.of('2.3');\n\n  /**\n   * AWS Elasticsearch 5.1\n   */\n  public static readonly V5_1 = ElasticsearchVersion.of('5.1');\n\n  /**\n   * AWS Elasticsearch 5.3\n   */\n  public static readonly V5_3 = ElasticsearchVersion.of('5.3');\n\n  /**\n   * AWS Elasticsearch 5.5\n   */\n  public static readonly V5_5 = ElasticsearchVersion.of('5.5');\n\n  /**\n   * AWS Elasticsearch 5.6\n   */\n  public static readonly V5_6 = ElasticsearchVersion.of('5.6');\n\n  /**\n   * AWS Elasticsearch 6.0\n   */\n  public static readonly V6_0 = ElasticsearchVersion.of('6.0');\n\n  /**\n   * AWS Elasticsearch 6.2\n   */\n  public static readonly V6_2 = ElasticsearchVersion.of('6.2');\n\n  /**\n   * AWS Elasticsearch 6.3\n   */\n  public static readonly V6_3 = ElasticsearchVersion.of('6.3');\n\n  /**\n   * AWS Elasticsearch 6.4\n   */\n  public static readonly V6_4 = ElasticsearchVersion.of('6.4');\n\n  /**\n   * AWS Elasticsearch 6.5\n   */\n  public static readonly V6_5 = ElasticsearchVersion.of('6.5');\n\n  /**\n   * AWS Elasticsearch 6.7\n   */\n  public static readonly V6_7 = ElasticsearchVersion.of('6.7');\n\n  /**\n   * AWS Elasticsearch 6.8\n   */\n  public static readonly V6_8 = ElasticsearchVersion.of('6.8');\n\n  /**\n   * AWS Elasticsearch 7.1\n   */\n  public static readonly V7_1 = ElasticsearchVersion.of('7.1');\n\n  /**\n   * AWS Elasticsearch 7.4\n   */\n  public static readonly V7_4 = ElasticsearchVersion.of('7.4');\n\n  /**\n   * AWS Elasticsearch 7.7\n   */\n  public static readonly V7_7 = ElasticsearchVersion.of('7.7');\n\n  /**\n   * AWS Elasticsearch 7.8\n   */\n  public static readonly V7_8 = ElasticsearchVersion.of('7.8');\n\n  /**\n   * AWS Elasticsearch 7.9\n   */\n  public static readonly V7_9 = ElasticsearchVersion.of('7.9');\n\n  /**\n   * AWS Elasticsearch 7.10\n   */\n  public static readonly V7_10 = ElasticsearchVersion.of('7.10');\n\n  /**\n   * Custom Elasticsearch version\n   * @param version custom version number\n   */\n  public static of(version: string) { return new ElasticsearchVersion(version); }\n\n  /**\n   *\n   * @param version Elasticsearch version number\n   */\n  private constructor(public readonly version: string) { }\n}", "language": "typescript"}
{"input": "A stage that deploys the `ProdStack`.", "output": "class ProdStage extends Stage {\n  constructor(scope: Construct, id: string, props?: StageProps) {\n    super(scope, id, props);\n    new ProdStack(this, 'ProdStack', props);\n  }\n}", "language": "typescript"}
{"input": "CDK helper function for IAM, WAF operations", "output": "def __init__(self, scope: Construct, id: str, *, \n                app_name: str, \n                producer_account_id: str, \n                 **kwargs) -> None:\n        super().__init__(scope, id, **kwargs)\n\n        # Create or reference the consumer event bus\n        consumer_event_bus = events.EventBus(\n            self, f\"{app_name}-consumer-event-bus\"\n        )\n\n        # Add policy to allow producer account to put events\n        consumer_event_bus.add_to_resource_policy(iam.PolicyStatement(\n            sid=\"allowProducerAccount\",\n            effect=iam.Effect.ALLOW,\n            principals=[iam.AccountPrincipal(producer_account_id)],\n            actions=[\"events:PutEvents\"],\n            resources=[consumer_event_bus.event_bus_arn]\n        ))\n\n        # Create consumer rules\n        consumer_rule = events.Rule(\n            self, f\"{app_name}-consumer-rule\",\n            event_bus=consumer_event_bus,\n            event_pattern=events.EventPattern(\n                source=['com.myapp.events'],\n                detail_type=['specific-event-type']\n            )\n        )\n\n        # Add target (e.g., CloudWatch)\n        log_group = logs.LogGroup(self, f\"{app_name}-consumer-logs\")\n        consumer_rule.add_target(targets.CloudWatchLogGroup(log_group))", "language": "python"}
{"input": "our main application stack", "output": "class UrlShortenerStack(WaltersCoStack):\n    def __init__(self, scope: Construct, id: str, **kwarg) -> None:\n        super().__init__(scope, id, **kwarg)\n\n        # define the table that maps short codes to URLs.\n        table = aws_dynamodb.Table(self, \"Table\",\n                                   partition_key=aws_dynamodb.Attribute(\n                                       name=\"id\",\n                                       type=aws_dynamodb.AttributeType.STRING),\n                                   read_capacity=10,\n                                   write_capacity=5)\n\n        # define the API gateway request handler. all API requests will go to the same function.\n        handler = aws_lambda.Function(self, \"UrlShortenerFunction\",\n                                      code=aws_lambda.Code.from_asset(\"./lambda\"),\n                                      handler=\"handler.main\",\n                                      timeout=Duration.minutes(5),\n                                      runtime=aws_lambda.Runtime.PYTHON_3_7)\n\n        # pass the table name to the handler through an environment variable and grant\n        # the handler read/write permissions on the table.\n        handler.add_environment('TABLE_NAME', table.table_name)\n        table.grant_read_write_data(handler)\n\n        # define the API endpoint and associate the handler\n        api = aws_apigateway.LambdaRestApi(self, \"UrlShortenerApi\",\n                                           handler=handler)\n\n        # map go.waltersco.co to this api gateway endpoint\n        # the domain name is a shared resource that can be accessed through the API in WaltersCoStack\n        # NOTE: you can comment this out if you want to bypass the domain name mapping\n        self.map_waltersco_subdomain('go', api)", "language": "python"}
{"input": "Stack that consumes the bucket", "output": "class Consumer extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props: ConsumerProps) {\n    super(scope, id, props);\n\n    const user = new iam.User(this, 'MyUser');\n    props.userBucket.grantReadWrite(user);\n  }\n}", "language": "typescript"}
{"input": "A container repository used to distribute container images in EC2 Image Builder", "output": "class Repository {\n  /**\n   * The ECR repository to use as the target container repository\n   *\n   * @param repository The ECR repository to use\n   */\n  public static fromEcr(repository: ecr.IRepository): Repository {\n    class Import extends Repository {\n      public readonly repositoryName: string = repository.repositoryName;\n      public readonly service: RepositoryService = RepositoryService.ECR;\n    }\n\n    return new Import();\n  }\n\n  /**\n   * The name of the container repository where the output container image is stored\n   */\n  abstract readonly repositoryName: string;\n\n  /**\n   * The service in which the container repository is hosted\n   */\n  abstract readonly service: RepositoryService;\n}", "language": "typescript"}
{"input": "CDK class PrefixList for AWS resource management", "output": "export class PrefixList extends PrefixListBase {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-ec2.PrefixList';\n\n  /**\n   * Look up prefix list by id.\n   */\n  public static fromPrefixListId(scope: Construct, id: string, prefixListId: string): IPrefixList {\n    class Import extends PrefixListBase {\n      public readonly prefixListId = prefixListId;\n\n      public get prefixListRef(): PrefixListReference {\n        return {\n          prefixListArn: Stack.of(scope).formatArn({\n            service: 'ec2',\n            resource: 'prefix-list',\n            resourceName: this.prefixListId,\n          }),\n          prefixListId,\n        };\n      }\n    }\n    return new Import(scope, id);\n  }\n\n  /**\n   * Look up prefix list by name\n   */\n  public static fromLookup(scope: Construct, id: string, options: PrefixListLookupOptions): IPrefixList {\n    if (Token.isUnresolved(options.prefixListName)) {\n      throw new ValidationError('All arguments to look up a managed prefix list must be concrete (no Tokens)', scope);\n    }\n\n    const dummyResponse = { PrefixListId: 'pl-xxxxxxxx' };\n    const response: PrefixListContextResponse[] = ContextProvider.getValue(scope, {\n      provider: cxschema.ContextProvider.CC_API_PROVIDER,\n      props: {\n        typeName: 'AWS::EC2::PrefixList',\n        propertyMatch: {\n          PrefixListName: options.prefixListName,\n          ...(options.ownerId ? { OwnerId: options.ownerId } : undefined),\n          ...(options.addressFamily ? { AddressFamily: options.addressFamily } : undefined),\n        },\n        propertiesToReturn: ['PrefixListId'],\n        expectedMatchCount: 'exactly-one',\n      } satisfies Omit<cxschema.CcApiContextQuery, 'account'|'region'>,\n      dummyValue: [dummyResponse] satisfies PrefixListContextResponse[],\n    }).value;\n\n    // getValue returns a list of result objects. We are expecting 1 result or Error.\n    if (response.length !== 1) {\n      throw new ValidationError('Unexpected response received from the context provider. Please clear out the context key using `cdk context --remove` and try again.', scope);\n    }\n\n    const prefixList = response[0];\n    return this.fromPrefixListId(scope, id, prefixList.PrefixListId);\n  }\n\n  /**\n   * The ID of the prefix list\n   *\n   * @attribute\n   */\n  public readonly prefixListId: string;\n\n  /**\n   * The name of the prefix list\n   *\n   * @attribute\n   */\n  public readonly prefixListName: string;\n\n  /**\n   * The ARN of the prefix list\n   *\n   * @attribute\n   */\n  public readonly prefixListArn: string;\n\n  /**\n   * The owner ID of the prefix list\n   *\n   */\n  public readonly ownerId: string;\n\n  /**\n   * The version of the prefix list\n   *\n   */\n  public readonly version: number;\n\n  /**\n   * The address family of the prefix list\n   *\n   */\n  public readonly addressFamily: string;\n\n  constructor(scope: Construct, id: string, props?: PrefixListProps) {\n    super(scope, id, {\n      physicalName: props?.prefixListName ?? Lazy.string({\n        produce: () => Names.uniqueResourceName(this, { maxLength: 255, allowedSpecialCharacters: '.-_' }),\n      }),\n    });\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    if (props?.prefixListName) {\n      if ( props.prefixListName.startsWith('com.amazonaws')) {\n        throw new ValidationError('The name cannot start with \\'com.amazonaws.\\'', this);\n      }\n      if (props.prefixListName.length > 255 ) {\n        throw new ValidationError('Lengths exceeding 255 characters cannot be set.', this);\n      }\n    }\n\n    this.prefixListName = this.physicalName;\n\n    let defaultMaxEntries = 1;\n    if (props?.entries && props.entries.length > 0) {\n      const entries = props.entries;\n      // Regular expressions for validating IPv6 addresses\n      if (props?.addressFamily === AddressFamily.IP_V6) {\n        const ipv6Regex = /^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$/i;\n        for (const entry of entries) {\n          if (!ipv6Regex.test(entry.cidr)) {\n            throw new ValidationError(`Invalid IPv6 address range: ${entry.cidr}`, this);\n          }\n        }\n      // Regular expressions for validating IPv4 addresses\n      } else {\n        const ipv4Regex = /^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$/i;\n        for (const entry of entries) {\n          if (!ipv4Regex.test(entry.cidr)) {\n            throw new ValidationError(`Invalid IPv4 address range: ${entry.cidr}`, this);\n          }\n        }\n      }\n\n      defaultMaxEntries = props.entries.length;\n    }\n\n    const prefixList = new CfnPrefixList(this, 'Resource', {\n      addressFamily: props?.addressFamily || AddressFamily.IP_V4,\n      maxEntries: props?.maxEntries || defaultMaxEntries,\n      prefixListName: this.prefixListName,\n      entries: props?.entries || [],\n    });\n\n    this.prefixListId = prefixList.attrPrefixListId;\n    this.prefixListArn = prefixList.attrArn;\n    this.ownerId = prefixList.attrOwnerId;\n    this.version = prefixList.attrVersion;\n    this.addressFamily = prefixList.addressFamily;\n  }\n\n  public get prefixListRef(): PrefixListReference {\n    return {\n      prefixListArn: this.prefixListArn,\n      prefixListId: this.prefixListId,\n    };\n  }\n}", "language": "typescript"}
{"input": "A CloudFormation resource which applies/restores a JSON patch into a Kubernetes resource. @see https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/", "output": "export class KubernetesPatch extends Construct {\n  constructor(scope: Construct, id: string, props: KubernetesPatchProps) {\n    super(scope, id);\n\n    const stack = Stack.of(this);\n\n    const provider = KubectlProvider.getKubectlProvider(this, props.cluster);\n    if (!provider) {\n      throw new Error('Kubectl Provider is not defined in this cluster. Define it when creating the cluster');\n    }\n\n    new CustomResource(this, 'Resource', {\n      serviceToken: provider.serviceToken,\n      resourceType: 'Custom::AWSCDK-EKS-KubernetesPatch',\n      properties: {\n        ResourceName: props.resourceName,\n        ResourceNamespace: props.resourceNamespace ?? 'default',\n        ApplyPatchJson: stack.toJsonString(props.applyPatch),\n        RestorePatchJson: stack.toJsonString(props.restorePatch),\n        ClusterName: props.cluster.clusterName,\n        PatchType: props.patchType ?? PatchType.STRATEGIC,\n      },\n    });\n  }\n}", "language": "typescript"}
{"input": "Imports are almost always implemented as a module-private inline class in the method itself. We extend ExampleResourceBase to reuse all of the logic inside it.", "output": "class Import extends ExampleResourceBase {\n      // we don't have an associated Role in this case\n      public readonly role = undefined;\n      // for imported resources, you always use the UnknownPrincipal,\n      // which ignores all modifications\n      public readonly grantPrincipal = new iam.UnknownPrincipal({ resource: this });\n\n      public readonly exampleResourceName = exampleResourceName;\n      // Since we have the name, we have to generate the ARN,\n      // using the Stack.formatArn helper method from the core library.\n      // We have to know the ARN components of ExampleResource in a few places, so,\n      // to avoid duplication, extract that into a module-private function\n      public readonly exampleResourceArn = Stack.of(scope)\n        .formatArn(exampleResourceArnComponents(exampleResourceName));\n    }\n\n    return new Import(scope, id);\n  }\n\n  // implement all fields that are abstract in ExampleResourceBase\n  public readonly exampleResourceArn: string;\n  public readonly exampleResourceName: string;\n  // while we know 'role' will actually never be undefined in this class,\n  // JSII does not allow changing the optionality of a field\n  // when overriding it, so it has to be 'role?'\n  public readonly role?: iam.IRole;\n  public readonly grantPrincipal: iam.IPrincipal;\n\n  /**\n   * The constructor of a construct has always 3 arguments:\n   * the parent Construct, the string identifier\n   * (locally unique within the scope of the parent),\n   * and a properties struct.\n   *\n   * If the props only have optional properties, like in our case,\n   * make sure to add a default value of an empty object to the props argument.\n   */\n  constructor(scope: Construct, id: string, props: ExampleResourceProps = {}) {\n    // Call the constructor from Resource superclass,\n\n    // which attaches this construct to the construct tree.\n    super(scope, id, {\n      // You need to let the Resource superclass know which of your properties\n      // signifies the resource's physical name.\n      // If your resource doesn't have a physical name,\n      // don't set this property.\n      // For more information on what exactly is a physical name,\n      // see the CDK guide: https://docs.aws.amazon.com/cdk/latest/guide/resources.html#resources_physical_names\n      physicalName: props.waitConditionHandleName,\n    }", "language": "typescript"}
{"input": "An allow list receipt filter.", "output": "export class AllowListReceiptFilter extends Construct {\n  constructor(scope: Construct, id: string, props: AllowListReceiptFilterProps) {\n    super(scope, id);\n\n    new ReceiptFilter(this, 'BlockAll');\n\n    props.ips.forEach(ip => {\n      new ReceiptFilter(this, `Allow${ip.replace(/[^\\d]/g, '')}`, {\n        ip,\n        policy: ReceiptFilterPolicy.ALLOW,\n      });\n    });\n  }\n}", "language": "typescript"}
{"input": "Applies mixins to constructs.", "output": "export class MixinApplicator {\n  private readonly scope: IConstruct;\n  private readonly selector: IConstructSelector;\n\n  constructor(\n    scope: IConstruct,\n    selector: IConstructSelector = ConstructSelector.all(),\n  ) {\n    this.scope = scope;\n    this.selector = selector;\n  }\n\n  /**\n   * Applies a mixin to selected constructs.\n   */\n  apply(...mixins: IMixin[]): this {\n    const constructs = this.selector.select(this.scope);\n    for (const construct of constructs) {\n      for (const mixin of mixins) {\n        if (mixin.supports(construct)) {\n          mixin.applyTo(construct);\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Applies a mixin and requires that it be applied to all constructs.\n   */\n  mustApply(...mixins: IMixin[]): this {\n    const constructs = this.selector.select(this.scope);\n    for (const construct of constructs) {\n      for (const mixin of mixins) {\n        if (!mixin.supports(construct)) {\n          throw new ValidationError(`Mixin ${mixin.constructor.name} could not be applied to ${construct.constructor.name} but was requested to.`, this.scope);\n        }\n        mixin.applyTo(construct);\n      }\n    }\n    return this;\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates S3, Lambda, IAM, API Gateway resources", "output": "export class CDKExampleLambdaApiStack extends Stack {\n    private restApi: RestApi\n    private lambdaFunction: Function\n    private bucket: s3.Bucket\n\n    constructor(scope: Construct, id: string, props: LambdaApiStackProps) {\n        super(scope, id, props)\n\n        this.bucket = new s3.Bucket(this, \"WidgetStore\")\n\n        this.restApi = new RestApi(this, this.stackName + \"RestApi\", {\n            deployOptions: {\n                stageName: \"beta\",\n                metricsEnabled: true,\n                loggingLevel: MethodLoggingLevel.INFO,\n                dataTraceEnabled: true,\n            },\n        })\n\n        const lambdaPolicy = new PolicyStatement()\n        lambdaPolicy.addActions(\"s3:ListBucket\")\n        lambdaPolicy.addActions(\"s3:getBucketLocation\")\n        lambdaPolicy.addResources(this.bucket.bucketArn)\n\n        this.lambdaFunction = new Function(this, props.functionName, {\n            functionName: props.functionName,\n            handler: \"handler.handler\",\n            runtime: Runtime.NODEJS_18_X,\n            code: new AssetCode(`./src`),\n            memorySize: 512,\n            timeout: Duration.seconds(10),\n            environment: {\n                BUCKET: this.bucket.bucketName,\n            },\n        })\n\n        this.lambdaFunction.addToRolePolicy(lambdaPolicy)\n\n        this.restApi.root.addMethod(\"GET\", new LambdaIntegration(this.lambdaFunction, {}))\n    }\n}", "language": "typescript"}
{"input": "A common superclass of all third-party build sources that are backed by Git.", "output": "class ThirdPartyGitSource extends GitSource {\n  public readonly badgeSupported: boolean = true;\n  protected readonly webhookFilters: FilterGroup[];\n  private readonly reportBuildStatus: boolean;\n  private readonly webhook?: boolean;\n  private readonly webhookTriggersBatchBuild?: boolean;\n  protected readonly buildStatusUrl?: string;\n\n  protected constructor(props: ThirdPartyGitSourceProps) {\n    super(props);\n\n    this.webhook = props.webhook;\n    this.reportBuildStatus = props.reportBuildStatus ?? true;\n    this.webhookFilters = props.webhookFilters || [];\n    this.webhookTriggersBatchBuild = props.webhookTriggersBatchBuild;\n    this.buildStatusUrl = props.buildStatusUrl;\n  }\n\n  public bind(_scope: Construct, project: IProject): SourceConfig {\n    const anyFilterGroupsProvided = this.webhookFilters.length > 0;\n    const webhook = this.webhook ?? (anyFilterGroupsProvided ? true : undefined);\n\n    if (!webhook && anyFilterGroupsProvided) {\n      throw new UnscopedValidationError('`webhookFilters` cannot be used when `webhook` is `false`');\n    }\n\n    if (!webhook && this.webhookTriggersBatchBuild) {\n      throw new UnscopedValidationError('`webhookTriggersBatchBuild` cannot be used when `webhook` is `false`');\n    }\n\n    const superConfig = super.bind(_scope, project);\n\n    if (this.webhookTriggersBatchBuild) {\n      project.enableBatchBuilds();\n    }\n\n    return {\n      sourceProperty: {\n        ...superConfig.sourceProperty,\n        reportBuildStatus: this.reportBuildStatus,\n      },\n      sourceVersion: superConfig.sourceVersion,\n      buildTriggers: webhook === undefined ? undefined : {\n        webhook,\n        buildType: this.webhookTriggersBatchBuild ? 'BUILD_BATCH' : undefined,\n        filterGroups: anyFilterGroupsProvided ? this.webhookFilters.map(fg => fg._toJson()) : undefined,\n      },\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK class MetricsReturnType for AWS resource management", "output": "export class MetricsReturnType extends InterfaceType {\n  public constructor(scope: IScope) {\n    super(scope, {\n      name: 'MetricWithDims',\n      export: true,\n      properties: [\n        {\n          name: 'namespace',\n          type: Type.STRING,\n          immutable: true,\n        },\n        {\n          name: 'metricName',\n          type: Type.STRING,\n          immutable: true,\n        },\n        {\n          name: 'statistic',\n          type: Type.STRING,\n          immutable: true,\n        },\n      ],\n    });\n\n    const D = this.addTypeParameter({ name: 'D' });\n\n    this.addProperty({\n      name: 'dimensionsMap',\n      type: D.asType(),\n      immutable: true,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class ScalaSparkEtlJob for AWS resource management", "output": "export class ScalaSparkEtlJob extends SparkJob {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = '@aws-cdk.aws-glue-alpha.ScalaSparkEtlJob';\n  public readonly jobArn: string;\n  public readonly jobName: string;\n\n  /**\n   * ScalaSparkEtlJob constructor\n   */\n  constructor(scope: Construct, id: string, props: ScalaSparkEtlJobProps) {\n    super(scope, id, props);\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    // Combine command line arguments into a single line item\n    const defaultArguments = {\n      ...this.executableArguments(props),\n      ...this.nonExecutableCommonArguments(props),\n    };\n\n    if ((!props.workerType && props.numberOfWorkers !== undefined) || (props.workerType && props.numberOfWorkers === undefined)) {\n      throw new ValidationError('Both workerType and numberOfWorkers must be set', this);\n    }\n\n    const jobResource = new CfnJob(this, 'Resource', {\n      name: props.jobName,\n      description: props.description,\n      role: this.role.roleArn,\n      command: {\n        name: JobType.ETL,\n        scriptLocation: this.codeS3ObjectUrl(props.script),\n      },\n      glueVersion: props.glueVersion ? props.glueVersion : GlueVersion.V4_0,\n      workerType: props.workerType ? props.workerType : WorkerType.G_1X,\n      numberOfWorkers: props.numberOfWorkers ? props.numberOfWorkers : 10,\n      maxRetries: props.jobRunQueuingEnabled ? 0 : props.maxRetries,\n      jobRunQueuingEnabled: props.jobRunQueuingEnabled ? props.jobRunQueuingEnabled : false,\n      executionProperty: props.maxConcurrentRuns ? { maxConcurrentRuns: props.maxConcurrentRuns } : undefined,\n      timeout: props.timeout?.toMinutes(),\n      connections: props.connections ? { connections: props.connections.map((connection) => connection.connectionName) } : undefined,\n      securityConfiguration: props.securityConfiguration?.securityConfigurationName,\n      tags: props.tags,\n      defaultArguments,\n    });\n\n    const resourceName = this.getResourceNameAttribute(jobResource.ref);\n    this.jobArn = this.buildJobArn(this, resourceName);\n    this.jobName = resourceName;\n  }\n\n  /**\n   * Set the executable arguments with best practices enabled by default\n   *\n   * @returns An array of arguments for Glue to use on execution\n   */\n  private executableArguments(props: ScalaSparkEtlJobProps) {\n    const args: { [key: string]: string } = {};\n    args['--job-language'] = JobLanguage.SCALA;\n    args['--class'] = props.className;\n    this.setupExtraCodeArguments(args, props);\n    return args;\n  }\n}", "language": "typescript"}
{"input": "HTTP route in APIGateway is a combination of the HTTP method and the path component. This class models that combination.", "output": "export class HttpRouteKey {\n  /**\n   * The catch-all route of the API, i.e., when no other routes match\n   */\n  public static readonly DEFAULT = new HttpRouteKey();\n\n  /**\n   * Create a route key with the combination of the path and the method.\n   * @param method default is 'ANY'\n   */\n  public static with(path: string, method?: HttpMethod) {\n    if (path !== '/' && (!path.startsWith('/') || path.endsWith('/'))) {\n      throw new UnscopedValidationError('A route path must always start with a \"/\" and not end with a \"/\"');\n    }\n    return new HttpRouteKey(method, path);\n  }\n\n  /**\n   * The method of the route\n   */\n  public readonly method: HttpMethod;\n  /**\n   * The key to the RouteKey as recognized by APIGateway\n   */\n  public readonly key: string;\n  /**\n   * The path part of this RouteKey.\n   * Returns `undefined` when `RouteKey.DEFAULT` is used.\n   */\n  public readonly path?: string;\n\n  private constructor(method?: HttpMethod, path?: string) {\n    this.method = method ?? HttpMethod.ANY;\n    this.path = path;\n    this.key = path ? `${method} ${path}` : '$default';\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates Lambda, IAM, API Gateway resources", "output": "class ApiSqsLambdaStack(Stack):\n\n    def __init__(self, scope: Construct, id: str, **kwargs) -> None:\n        super().__init__(scope, id, **kwargs)\n\n        #Create the SQS queue\n        queue = sqs.Queue(self, \"SQSQueue\")\n\n        #Create the API GW service role with permissions to call SQS\n        rest_api_role = iam.Role(\n            self,\n            \"RestAPIRole\",\n            assumed_by=iam.ServicePrincipal(\"apigateway.amazonaws.com\"),\n            managed_policies=[iam.ManagedPolicy.from_aws_managed_policy_name(\"AmazonSQSFullAccess\")]\n        )\n\n        #Create an API GW Rest API\n        base_api = apigw.RestApi(self, 'ApiGW',rest_api_name='TestAPI')\n        base_api.root.add_method(\"ANY\")\n\n        #Create a resource named \"example\" on the base API\n        api_resource = base_api.root.add_resource('example')\n\n\n        #Create API Integration Response object: https://docs.aws.amazon.com/cdk/api/latest/python/aws_cdk.aws_apigateway/IntegrationResponse.html\n        integration_response = apigw.IntegrationResponse(\n            status_code=\"200\",\n            response_templates={\"application/json\": \"\"},\n\n        )\n\n        #Create API Integration Options object: https://docs.aws.amazon.com/cdk/api/latest/python/aws_cdk.aws_apigateway/IntegrationOptions.html\n        api_integration_options = apigw.IntegrationOptions(\n            credentials_role=rest_api_role,\n            integration_responses=[integration_response],\n            request_templates={\"application/json\": \"Action=SendMessage&MessageBody=$input.body\"},\n            passthrough_behavior=apigw.PassthroughBehavior.NEVER,\n            request_parameters={\"integration.request.header.Content-Type\": \"'application/x-www-form-urlencoded'\"},\n        )\n\n        #Create AWS Integration Object for SQS: https://docs.aws.amazon.com/cdk/api/latest/python/aws_cdk.aws_apigateway/AwsIntegration.html\n        api_resource_sqs_integration = apigw.AwsIntegration(\n            service=\"sqs\",\n            integration_http_method=\"POST\",\n            path=\"{}/{}\".format(Aws.ACCOUNT_ID, queue.queue_name),\n            options=api_integration_options\n        )\n\n        #Create a Method Response Object: https://docs.aws.amazon.com/cdk/api/latest/python/aws_cdk.aws_apigateway/MethodResponse.html\n        method_response = apigw.MethodResponse(status_code=\"200\")\n\n        #Add the API GW Integration to the \"example\" API GW Resource\n        api_resource.add_method(\n            \"POST\",\n            api_resource_sqs_integration,\n            method_responses=[method_response]\n        )\n\n        #Creating Lambda function that will be triggered by the SQS Queue\n        sqs_lambda = _lambda.Function(self,'SQSTriggerLambda',\n            handler='lambda-handler.handler',\n            runtime=_lambda.Runtime.PYTHON_3_11,\n            code=_lambda.Code.from_asset('lambda'),\n        )\n\n        #Create an SQS event source for Lambda\n        sqs_event_source = lambda_event_source.SqsEventSource(queue)\n\n        #Add SQS event source to the Lambda function\n        sqs_lambda.add_event_source(sqs_event_source)", "language": "python"}
{"input": "Stack that uses the key", "output": "class UseStack extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props: UseStackProps) {\n    super(scope, id, props);\n\n    // Use the IKey object here.\n    new kms.Alias(this, 'Alias', {\n      aliasName: 'alias/foo',\n      targetKey: props.key,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates S3, Lambda, EC2, KMS resources", "output": "class TestStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const build = new gamelift.Build(this, 'Build', {\n      content: gamelift.Content.fromAsset(path.join(__dirname, 'my-game-build')),\n      operatingSystem: gamelift.OperatingSystem.AMAZON_LINUX_2,\n    });\n\n    const fleet = new gamelift.BuildFleet(this, 'BuildFleet', {\n      fleetName: 'test-fleet',\n      content: build,\n      ingressRules: [{\n        source: gamelift.Peer.anyIpv4(),\n        port: gamelift.Port.tcp(1935),\n      }],\n      instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n      runtimeConfiguration: {\n        gameSessionActivationTimeout: Duration.seconds(300),\n        maxConcurrentGameSessionActivations: 1,\n        serverProcesses: [{\n          launchPath: '/local/game/TestApplicationServer',\n          parameters: 'port:1935 gameSessionLengthSeconds:20',\n          concurrentExecutions: 1,\n        }],\n      },\n    });\n\n    new gamelift.Alias(this, 'FleetAlias', {\n      aliasName: 'test-alias',\n      fleet: fleet,\n    });\n\n    new gamelift.Alias(this, 'TerminalAlias', {\n      aliasName: 'test-alias',\n      terminalMessage: 'a terminal message',\n    });\n  }\n}", "language": "typescript"}
{"input": "platform supported by docker", "output": "export class Platform {\n  /**\n   * Build for linux/amd64\n   */\n  public static readonly LINUX_AMD64 = new Platform('linux/amd64');\n\n  /**\n   * Build for linux/arm64\n   */\n  public static readonly LINUX_ARM64 = new Platform('linux/arm64');\n\n  /**\n   * Used to specify a custom platform\n   * Use this if the platform name is not yet supported by the CDK.\n   *\n   * @param platform The platform to use for docker build\n   */\n  public static custom(platform: string) {\n    return new Platform(platform);\n  }\n\n  /**\n   * @param platform The platform to use for docker build\n   */\n  private constructor(public readonly platform: string) { }\n}", "language": "typescript"}
{"input": "CDK class RotationSchedule for AWS resource management", "output": "export class RotationSchedule extends Resource {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-secretsmanager.RotationSchedule';\n\n  constructor(scope: Construct, id: string, props: RotationScheduleProps) {\n    super(scope, id);\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    if ((!props.rotationLambda && !props.hostedRotation) || (props.rotationLambda && props.hostedRotation)) {\n      throw new ValidationError('One of `rotationLambda` or `hostedRotation` must be specified.', this);\n    }\n\n    if (props.rotationLambda?.permissionsNode.defaultChild) {\n      if (props.secret.encryptionKey) {\n        props.secret.encryptionKey.grantEncryptDecrypt(\n          new kms.ViaServicePrincipal(\n            `secretsmanager.${Stack.of(this).region}.amazonaws.com`,\n            props.rotationLambda.grantPrincipal,\n          ),\n        );\n      }\n\n      const grant = props.rotationLambda.grantInvoke(new iam.ServicePrincipal('secretsmanager.amazonaws.com'));\n      grant.applyBefore(this);\n\n      props.rotationLambda.addToRolePolicy(\n        new iam.PolicyStatement({\n          actions: [\n            'secretsmanager:DescribeSecret',\n            'secretsmanager:GetSecretValue',\n            'secretsmanager:PutSecretValue',\n            'secretsmanager:UpdateSecretVersionStage',\n          ],\n          resources: [props.secret.secretFullArn ? props.secret.secretFullArn : `${props.secret.secretArn}-??????`],\n        }),\n      );\n      props.rotationLambda.addToRolePolicy(\n        new iam.PolicyStatement({\n          actions: [\n            'secretsmanager:GetRandomPassword',\n          ],\n          resources: ['*'],\n        }),\n      );\n    }\n\n    let scheduleExpression: string | undefined;\n    if (props.automaticallyAfter) {\n      const automaticallyAfterMillis = props.automaticallyAfter.toMilliseconds();\n      if (automaticallyAfterMillis > 0) {\n        if (automaticallyAfterMillis < Duration.hours(4).toMilliseconds()) {\n          throw new ValidationError(`automaticallyAfter must not be smaller than 4 hours, got ${props.automaticallyAfter.toHours()} hours`, this);\n        }\n        if (automaticallyAfterMillis > Duration.days(1000).toMilliseconds()) {\n          throw new ValidationError(`automaticallyAfter must not be greater than 1000 days, got ${props.automaticallyAfter.toDays()} days`, this);\n        }\n        scheduleExpression = Schedule.rate(props.automaticallyAfter).expressionString;\n      }\n    } else {\n      scheduleExpression = Schedule.rate(Duration.days(30)).expressionString;\n    }\n\n    let rotationRules: CfnRotationSchedule.RotationRulesProperty | undefined;\n    if (scheduleExpression) {\n      rotationRules = {\n        scheduleExpression,\n      };\n    }\n\n    new CfnRotationSchedule(this, 'Resource', {\n      secretId: props.secret.secretArn,\n      rotationLambdaArn: props.rotationLambda?.functionArn,\n      hostedRotationLambda: props.hostedRotation?.bind(props.secret, this),\n      rotationRules,\n      rotateImmediatelyOnUpdate: props.rotateImmediatelyOnUpdate,\n    });\n\n    // Prevent secrets deletions when rotation is in place\n    props.secret.denyAccountRootDelete();\n  }\n}", "language": "typescript"}
{"input": "CDK class GlobalDDBTableCMK for AWS resource management", "output": "export class GlobalDDBTableCMK extends Stack {\n  constructor(scope: Construct, id: string, props: Props) {\n    super(scope, id, props);\n\n    const cmkStack = new CMKStack(this, 'cmk-stack', {\n      tableName: props.tableName,\n      keyReplicaRegions: props.replicationRegions,\n      keyAlias: props.keyAlias\n    });\n\n    const ddbStack = new DynamoDBStack(this, 'ddb-stack', {\n      tableName: props.tableName,\n      tableReplicaRegions: [this.region, ...props.replicationRegions].map((region: string) => (\n        {\n          region,\n          keyExportName: cmkStack.getKeyReplicaExportNames(region),\n        }\n      )),\n    });\n\n    ddbStack.addDependency(cmkStack);\n  }\n}", "language": "typescript"}
{"input": "CDK class CommonGithubSource for AWS resource management", "output": "class CommonGithubSource extends ThirdPartyGitSource {\n  private readonly buildStatusContext?: string;\n\n  constructor(props: CommonGithubSourceProps) {\n    super(props);\n    this.buildStatusContext = props.buildStatusContext;\n  }\n\n  public bind(scope: Construct, project: IProject): SourceConfig {\n    const superConfig = super.bind(scope, project);\n    return {\n      sourceProperty: {\n        ...superConfig.sourceProperty,\n        buildStatusConfig: this.buildStatusContext !== undefined || this.buildStatusUrl !== undefined\n          ? {\n            context: this.buildStatusContext,\n            targetUrl: this.buildStatusUrl,\n          }\n          : undefined,\n      },\n      sourceVersion: superConfig.sourceVersion,\n      buildTriggers: superConfig.buildTriggers,\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates EC2, VPC, CloudFormation, ELB / ALB / NLB resources", "output": "class LoadBalancerStack extends cdk.Stack {\n  constructor(app: cdk.App, id: string) {\n    super(app, id);\n\n    const vpc = new ec2.Vpc(this, 'VPC');\n\n    const asg = new autoscaling.AutoScalingGroup(this, 'ASG', {\n      vpc,\n      instanceType: ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE4_GRAVITON, ec2.InstanceSize.MICRO),\n      machineImage: ec2.MachineImage.latestAmazonLinux2023({\n        cpuType: ec2.AmazonLinuxCpuType.ARM_64\n      })\n    });\n\n    const lb = new elbv2.ApplicationLoadBalancer(this, 'LB', {\n      vpc,\n      internetFacing: true\n    });\n\n    const listener = lb.addListener('Listener', {\n      port: 80,\n    });\n\n    listener.addTargets('Target', {\n      port: 80,\n      targets: [asg]\n    });\n\n    listener.connections.allowDefaultPortFromAnyIpv4('Open to the world');\n\n    asg.scaleOnRequestCount('AModestLoad', {\n      targetRequestsPerMinute: 60,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class RedshiftEnv for AWS resource management", "output": "class RedshiftEnv extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const vpc = new ec2.Vpc(this, 'VPC', { restrictDefaultSecurityGroup: false });\n    const role = new iam.Role(this, 'RoleA', {\n      assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n    });\n\n    // Adding iam role after cluster creation\n    const redshiftCluster = new redshift.Cluster(this, 'Cluster', {\n      vpc: vpc,\n      vpcSubnets: {\n        subnetType: ec2.SubnetType.PUBLIC,\n      },\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      roles: [new iam.Role(this, 'RoleB', {\n        assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n      })],\n      removalPolicy: RemovalPolicy.DESTROY,\n    });\n\n    redshiftCluster.addIamRole(role);\n  }\n}", "language": "typescript"}
{"input": "Returns an attribute value or list of values for a specific parameter and attribute.", "output": "class FnValueOf extends FnBase {\n  /**\n   * Creates an ``Fn::ValueOf`` function.\n   * @param parameterOrLogicalId The name of a parameter for which you want to retrieve attribute values. The parameter must be declared in the Parameters section of the template.\n   * @param attribute The name of an attribute from which you want to retrieve a value.\n   */\n  constructor(parameterOrLogicalId: string, attribute: string) {\n    super('Fn::ValueOf', [parameterOrLogicalId, attribute]);\n  }\n}", "language": "typescript"}
{"input": "This is the Stack containing a simple ECS Service that uses the provided ContainerImage.", "output": "export class EcsAppStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props: EcsAppStackProps) {\n    super(scope, id, props);\n\n    const taskDefinition = new ecs.TaskDefinition(this, 'TaskDefinition', {\n      compatibility: ecs.Compatibility.FARGATE,\n      cpu: '1024',\n      memoryMiB: '2048',\n    });\n    taskDefinition.addContainer('AppContainer', {\n      image: props.image,\n    });\n    new ecs.FargateService(this, 'EcsService', {\n      taskDefinition,\n      cluster: new ecs.Cluster(this, 'Cluster', {\n        vpc: new ec2.Vpc(this, 'Vpc', {\n          restrictDefaultSecurityGroup: false,\n          maxAzs: 1,\n        }),\n      }),\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class UbergenPackageVisibility for AWS resource management", "output": "export class UbergenPackageVisibility extends ValidationRule {\n  public readonly name = 'ubergen/package-visibility';\n\n  // The ONLY (non-alpha) packages that should be published for v2.\n  // These include dependencies of the CDK CLI (aws-cdk).\n  private readonly v2PublicPackages = [\n    '@aws-cdk/cli-plugin-contract',\n    '@aws-cdk/cloudformation-diff',\n    '@aws-cdk/cx-api',\n    '@aws-cdk/mixins-preview',\n    '@aws-cdk/region-info',\n    'aws-cdk-lib',\n    'aws-cdk',\n    'awslint',\n    'cdk',\n    '@aws-cdk/integ-runner',\n    '@aws-cdk-testing/cli-integ',\n  ];\n\n  public validate(pkg: PackageJson): void {\n    if (cdkMajorVersion() === 2) {\n      // Only alpha packages and packages in the publicPackages list should be \"public\". Everything else should be private.\n      if (this.v2PublicPackages.includes(pkg.json.name) && pkg.json.private === true) {\n        pkg.report({\n          ruleName: this.name,\n          message: 'Package must be public',\n          fix: () => {\n            delete pkg.json.private;\n          },\n        });\n      } else if (!this.v2PublicPackages.includes(pkg.json.name) && pkg.json.private !== true && !pkg.packageName.endsWith('-alpha')) {\n        pkg.report({\n          ruleName: this.name,\n          message: 'Package must not be public',\n          fix: () => {\n            delete pkg.json.private;\n            pkg.json.private = true;\n          },\n        });\n      }\n    }\n  }\n}", "language": "typescript"}
{"input": "Represents a function in a function schema", "output": "export class Function {\n  /**\n   * The name of the function\n   */\n  public readonly name: string;\n\n  /**\n   * Description of the function\n   */\n  public readonly description: string;\n\n  /**\n   * Parameters for the function\n   */\n  public readonly parameters: Record<string, FunctionParameter>;\n\n  /**\n   * Whether to require confirmation before executing the function\n   */\n  public readonly requireConfirmation: RequireConfirmation;\n\n  constructor(props: FunctionProps) {\n    // Validate function name\n    const nameErrors = validation.validateStringFieldLength({\n      fieldName: 'function name',\n      value: props.name,\n      minLength: 1,\n      maxLength: 100,\n    });\n\n    if (nameErrors.length > 0) {\n      throw new validation.ValidationError(nameErrors.join('\\n'));\n    }\n\n    // Validate function description\n    const descErrors = validation.validateStringFieldLength({\n      fieldName: 'function description',\n      value: props.description,\n      minLength: 1,\n      maxLength: 500,\n    });\n\n    if (descErrors.length > 0) {\n      throw new validation.ValidationError(descErrors.join('\\n'));\n    }\n\n    this.name = props.name;\n    this.description = props.description;\n\n    // Convert parameters object to a record of FunctionParameter instances\n    this.parameters = {};\n    if (props.parameters) {\n      Object.entries(props.parameters).forEach(([name, paramProps]) => {\n        // Validate parameter name\n        const paramNameErrors = validation.validateStringFieldLength({\n          fieldName: 'parameter name',\n          value: name,\n          minLength: 1,\n          maxLength: 100,\n        });\n\n        if (paramNameErrors.length > 0) {\n          throw new validation.ValidationError(paramNameErrors.join('\\n'));\n        }\n\n        this.parameters[name] = new FunctionParameter(paramProps);\n      });\n    }\n\n    this.requireConfirmation = props.requireConfirmation ?? RequireConfirmation.DISABLED;\n  }\n\n  /**\n   * Render the function as a CloudFormation property\n   * @internal\n   */\n  public _render(): any {\n    const parametersObj: Record<string, any> = {};\n\n    Object.entries(this.parameters).forEach(([name, param]) => {\n      parametersObj[name] = param._render();\n    });\n    return {\n      name: this.name,\n      description: this.description,\n      parameters: parametersObj,\n      requireConfirmation: this.requireConfirmation,\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK class NamePart for AWS resource management", "output": "class NamePart {\n  public readonly bareStr: string;\n\n  constructor(bareStr: string) {\n    this.bareStr = bareStr;\n  }\n\n  public abstract generate(): string;\n}", "language": "typescript"}
{"input": "CDK class AssessmentTemplate for AWS resource management", "output": "export class AssessmentTemplate extends Resource {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-inspector.AssessmentTemplate';\n\n  /**\n   * Creates an AssessmentTemplate from an existing CfnAssessmentTemplate.\n   *\n   * This method is provided to bridge the gap with L2 constructs since no L2 constructs\n   * exist for Inspector resources yet. It allows working with CfnAssessmentTemplate (L1)\n   * resources through the IAssessmentTemplate interface.\n   */\n  public static fromCfnAssessmentTemplate(scope: Construct, id: string, template: CfnAssessmentTemplate): IAssessmentTemplate {\n    return new class extends Resource implements IAssessmentTemplate {\n      public readonly assessmentTemplateArn: string;\n      constructor() {\n        super(scope, id);\n        this.assessmentTemplateArn = template.attrArn;\n      }\n      public get assessmentTemplateRef() {\n        return {\n          assessmentTemplateArn: this.assessmentTemplateArn,\n        };\n      }\n    }();\n  }\n}", "language": "typescript"}
{"input": "CDK class PropertyUpdater for AWS resource management", "output": "export class PropertyUpdater extends MetadataUpdater {\n  private classProps: Record<string, Record<string, any>>;\n  constructor(dir: string) {\n    super(dir);\n\n    this.classProps = {};\n  }\n\n  public execute(): void {\n    // Process each file in the project\n    this.project.getSourceFiles().forEach((sourceFile) => {\n      const classes = this.getCdkResourceClasses(sourceFile.getFilePath());\n\n      for (const resource of classes) {\n        this.extractConstructorProps(resource.filePath, resource.node, resource.className)\n        this.extractMethodProps(resource.filePath, resource.node, resource.className)\n      }\n    });\n\n    this.generateFileContent();\n  }\n\n  private extractMethodProps(filePath: string, classDeclaration: ClassDeclaration, className: string) {\n    // Get module name from file path\n    const moduleName = this.getModuleName(filePath);\n    const methods: Record<string, any> = {};\n\n    classDeclaration.getMethods().forEach((method) => {\n      if (method.hasModifier(SyntaxKind.PublicKeyword) && !method.hasModifier(SyntaxKind.StaticKeyword)) {\n        const methodName = method.getName();\n\n        // Extract parameters with their types\n        const parameters = method.getParameters().map(param => this.getPropertyType(param.getType()));\n\n        methods[methodName] = parameters;\n        console.log(`Module: ${moduleName}, Method: ${methodName}, Params:`, parameters);\n      }\n    });\n\n    if (!methods) {\n      return;\n    }\n\n    this.classProps[moduleName] = this.classProps[moduleName] || {};\n    // Ensure class exists within the module\n    this.classProps[moduleName][className] = {\n      ...this.classProps[moduleName][className],\n      ...methods, // Merge with new methods\n    };\n  }\n\n  private extractConstructorProps(filePath: string, node: ClassDeclaration, className: string) {\n    // Get module name from file path\n    const moduleName = this.getModuleName(filePath);\n\n    // Parse Constructor parameters\n    const props = this.parseConstructorProps(node, className);\n\n    if (!props) {\n      return;\n    }\n\n    const content = this.classProps[moduleName] || {};\n    this.classProps[moduleName] = {\n      ...content,\n      ...props,\n    };\n  }\n\n  private generateFileContent() {\n    const template = `/* eslint-disable @stylistic/quote-props */\n/* eslint-disable @stylistic/comma-dangle */\n/*\n * Do not edit this file manually. To prevent misconfiguration, this file\n * should only be modified by an automated GitHub workflow, that ensures\n * that the regions present in this list correspond to all the regions\n * where we have the AWS::CDK::Metadata handler deployed.\n *\n * See: https://github.com/aws/aws-cdk/issues/27189\n */\n\nexport const AWS_CDK_CONSTRUCTOR_PROPS: { [key: string]: any } = $PROPS;\n`;\n\n      // Convert the enums object to a JSON string\n    const jsonContent = JSON.stringify(this.classProps, null, 2).replace(/\"/g, \"'\");\n\n    // Replace the placeholder with the JSON object\n    const content = template.replace(\"$PROPS\", jsonContent);\n\n    const outputPath = path.resolve(\n      __dirname,\n      \"../../../../packages/aws-cdk-lib/core/lib/analytics-data-source/classes.ts\"\n    );\n\n    // Write the generated file\n    fs.writeFileSync(outputPath, content);\n    console.log(`Metadata file written to: ${outputPath}`);\n  }\n\n  // Helper method to extract module name from file path\n  private getModuleName(filePath: string): string {\n    const pathParts = filePath.split('/');\n    // Assuming file paths are like '/packages/aws-cdk-lib/aws-lambda/Function.ts'\n    const moduleName = pathParts.slice(pathParts.length - 4, pathParts.length - 2).join('.');\n    return moduleName;\n  }\n\n  private getPropertyType(type: any, processedTypes: Set<string> = new Set()): any {\n    if (type.isBoolean()) {\n      return type.getText();\n    }\n\n    if (type.isUnion()) {\n      // Get all types in the union and find the first non-undefined type\n      // CDK doesn't support complex union type so we can safely get the first\n      // non-undefined type\n      const unionTypes = type.getUnionTypes();\n      type = unionTypes.find((t: any) => t.getText() !== 'undefined') || type;\n\n      if (type.isLiteral() && (type.getText() === 'true' || type.getText() === 'false')) {\n        return 'boolean';\n      }\n    }\n\n    const symbol = type.getSymbol();\n    if (symbol) {\n      const declarations = symbol.getDeclarations();\n      if (declarations.length > 0) {\n        const decl = declarations[0];\n        // Check if the type is an Enum Member\n        if (decl.getKindName() === 'EnumMember') {\n          const parent = decl.getParent(); // Get the parent of the Enum Member\n          if (parent && parent.getKindName() === 'EnumDeclaration') {\n            const enumDecl = parent.asKindOrThrow(SyntaxKind.EnumDeclaration);\n            const enumName = enumDecl.getName();\n            return enumName; // Return the name of the parent enum\n          }\n        }\n      }\n    }\n\n    if (type.isArray()) {\n      // If it's an array, get the type of the array elements\n      const elementType = type.getArrayElementType();\n      if (elementType) {\n        return this.getPropertyType(elementType, processedTypes); // Recursively resolve the element type\n      }\n      return '*';\n    }\n\n    if (type.isClass() || type.isInterface()) {\n      // Generate a unique identifier for the type to track its processed state\n      const typeId = type?.getSymbol()?.getFullyQualifiedName();\n\n      // If the type has already been processed, avoid recursion (cycle detection)\n      if (typeId && processedTypes.has(typeId)) {\n        // TODO: maybe use the cache instead\n        return undefined;\n      }\n\n      // Add this type to the processed set\n      if (typeId) {\n        processedTypes.add(typeId);\n      }\n\n      if (type.isClass()) {\n        // Redact class object\n        return '*'\n      } else {\n        // Handle the case where the type is a class or interface\n        return this.resolveInterfaceType(type, processedTypes);\n      }\n    }\n\n    return '*';\n  }\n\n  private resolveInterfaceType(type: any, processedTypes: Set<string>): any {\n    // If it's a reference to another interface type, resolve its properties recursively\n    const symbol = type.getSymbol();\n\n    if (symbol) {\n      const declarations = symbol.getDeclarations();\n      if (declarations.length > 0) {\n        const firstDeclaration = declarations[0];\n        const members = firstDeclaration.getType().getProperties();\n        const resolvedObject: Record<string, any> = {};\n\n        members.forEach((member: Symbol) => {\n          const memberType = member.getValueDeclaration()?.getType() || member.getDeclaredType();\n          if (memberType.getCallSignatures().length > 0) {\n            return;\n          }\n          const propName = member.getName();\n          const nestedType = this.getPropertyType(memberType, processedTypes);\n          if (nestedType) {\n            resolvedObject[propName] = nestedType;\n          }\n        });\n\n        return Object.keys(resolvedObject).length === 0 ? '*' : resolvedObject;\n      }\n    }\n    return undefined; // If unable to resolve, return undefined\n  }\n\n  private parseConstructorProps(node: ClassDeclaration, className: string) {\n    const constructor = node.getConstructors()?.[0];\n\n    if (constructor) {\n      const parameters = constructor.getParameters();\n      const props = parameters[2];\n\n      if (props) {\n        const type = props.getType();\n\n        if (type?.isObject()) {\n          const properties = type.getProperties();\n          const propertyTypes: Record<string, any> = {};\n\n          properties.forEach((property: Symbol) => {\n            const propName = property.getName();\n            const nestedType = this.getPropertyType(property.getValueDeclaration()?.getType());\n            if (nestedType) {\n              propertyTypes[propName] = nestedType;\n            }\n          });\n\n          return { [className]: propertyTypes };\n        }\n      }\n    }\n    return undefined;\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates EC2, CloudFormation, ELB / ALB / NLB resources", "output": "class ASGStack(Stack):\n\n    def __init__(self, scope: Construct, id: str, props, **kwargs) -> None:\n        super().__init__(scope, id, **kwargs)\n\n        userdata_file = open(\"./userdata.sh\", \"rb\").read()\n\n        # Creates a userdata object for Linux hosts\n        userdata = ec2.UserData.for_linux()\n        # Adds one or more commands to the userdata object.\n        userdata.add_commands(str(userdata_file, 'utf-8'))\n\n\n        asg = autoscaling.AutoScalingGroup(\n            self,\n            \"app-asg\",\n            vpc=props['vpc'],\n            instance_type=ec2.InstanceType.of(\n                ec2.InstanceClass.MEMORY5, ec2.InstanceSize.XLARGE\n            ),\n            machine_image=ec2.AmazonLinuxImage(\n                generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2\n                ),\n            key_name=\"evan\",\n            vpc_subnets=ec2.SubnetSelection(subnet_type=SubnetType.PRIVATE_WITH_NAT),\n            user_data=userdata,\n        )\n\n        # Creates a security group for our application\n        sg_nextcloud = ec2.SecurityGroup(\n                self,\n                id=\"sg_nextcloud\",\n                vpc=props['vpc'],\n                security_group_name=\"sg_nextcloud\"\n        )\n\n        # Allows only the IP of \"123.123.123.123\"\n        # to access this security group for SSH\n        sg_nextcloud.add_ingress_rule(\n            peer=ec2.Peer.ipv4(\"151.66.226.30/32\"),\n            connection=ec2.Port.tcp(22)\n        )\n\n        # Creates a security group for the application load balancer\n        sg_alb = ec2.SecurityGroup(\n                self,\n                id=\"sg_alb\",\n                vpc=props['vpc'],\n                security_group_name=\"sg_alb\"\n        )\n\n        # Allows connections from security group \"sg_alb\"\n        # inside the \"sg_nextcloud\" security group to access port 8080\n        # where our app listens\n        sg_nextcloud.connections.allow_from(\n                sg_alb, ec2.Port.tcp(8080), \"Ingress\")\n\n        # Adds the security group 'sg_nextcloud' to the autoscaling group\n        asg.add_security_group(sg_nextcloud)\n\n        # Creates an application load balance\n        lb = elbv2.ApplicationLoadBalancer(\n                self,\n                \"ALB\",\n                vpc=props['vpc'],\n                security_group=sg_alb,\n                internet_facing=True)\n\n        listener = lb.add_listener(\"Listener\", port=80)\n        # Adds the autoscaling group's (asg) instance to be registered\n        # as targets on port 8080\n        listener.add_targets(\"Target\", port=8080, targets=[asg])\n        # This creates a \"0.0.0.0/0\" rule to allow every one to access the\n        # application\n        listener.connections.allow_default_port_from_any_ipv4(\n                \"Open to the world\"\n                )", "language": "python"}
{"input": "An `IPrincipal` entity that can be used as the target of `grant` calls, used by the `SourceTableAttachedPolicy` class so it can act as an `IGrantable`.", "output": "class SourceTableAttachedPrincipal extends iam.PrincipalBase {\n  public constructor(private readonly role: iam.IRole, private readonly policy: iam.ManagedPolicy) {\n    super();\n  }\n\n  public get policyFragment(): iam.PrincipalPolicyFragment {\n    return this.role.policyFragment;\n  }\n\n  public addToPrincipalPolicy(statement: iam.PolicyStatement): iam.AddToPrincipalPolicyResult {\n    this.policy.addStatements(statement);\n    return {\n      policyDependable: this.policy,\n      statementAdded: true,\n    };\n  }\n\n  public dedupeString(): string | undefined {\n    return undefined;\n  }\n}", "language": "typescript"}
{"input": "CDK class KafkaStorageModeTest for AWS resource management", "output": "class KafkaStorageModeTest extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n    const vpc = new Vpc(this, 'Vpc', { maxAzs: 2, restrictDefaultSecurityGroup: false });\n\n    storageModeArray.forEach(sMode => {\n      const clusterMode = sMode.toLowerCase();\n      new msk.Cluster(this, `storageMode${clusterMode}`, {\n        clusterName: `${clusterMode}-cluster`,\n        kafkaVersion: KafkaVersion.V2_8_2_TIERED,\n        storageMode: sMode,\n        vpc,\n        removalPolicy: RemovalPolicy.DESTROY,\n      });\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class NetworkLoadBalancedFargateService for AWS resource management", "output": "export class NetworkLoadBalancedFargateService extends NetworkLoadBalancedServiceBase {\n  /**\n   * Uniquely identifies this class.\n   */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-ecs-patterns.NetworkLoadBalancedFargateService';\n\n  public readonly assignPublicIp: boolean;\n  /**\n   * The Fargate service in this construct.\n   */\n  public readonly service: FargateService;\n  /**\n   * The Fargate task definition in this construct.\n   */\n  public readonly taskDefinition: FargateTaskDefinition;\n\n  /**\n   * Constructs a new instance of the NetworkLoadBalancedFargateService class.\n   */\n  constructor(scope: Construct, id: string, props: NetworkLoadBalancedFargateServiceProps = {}) {\n    super(scope, id, props);\n\n    this.assignPublicIp = props.assignPublicIp ?? false;\n\n    if (props.taskDefinition && props.taskImageOptions) {\n      throw new ValidationError('You must specify either a taskDefinition or an image, not both.', this);\n    } else if (props.taskDefinition) {\n      this.taskDefinition = props.taskDefinition;\n    } else if (props.taskImageOptions) {\n      const taskImageOptions = props.taskImageOptions;\n      this.taskDefinition = new FargateTaskDefinition(this, 'TaskDef', {\n        memoryLimitMiB: props.memoryLimitMiB,\n        cpu: props.cpu,\n        ephemeralStorageGiB: props.ephemeralStorageGiB,\n        executionRole: taskImageOptions.executionRole,\n        taskRole: taskImageOptions.taskRole,\n        family: taskImageOptions.family,\n        runtimePlatform: props.runtimePlatform,\n      });\n\n      // Create log driver if logging is enabled\n      const enableLogging = taskImageOptions.enableLogging ?? true;\n      const logDriver = taskImageOptions.logDriver ?? (enableLogging ? this.createAWSLogDriver(this.node.id) : undefined);\n\n      const containerName = taskImageOptions.containerName ?? 'web';\n      const container = this.taskDefinition.addContainer(containerName, {\n        image: taskImageOptions.image,\n        logging: logDriver,\n        environment: taskImageOptions.environment,\n        secrets: taskImageOptions.secrets,\n        dockerLabels: taskImageOptions.dockerLabels,\n      });\n      container.addPortMappings({\n        containerPort: taskImageOptions.containerPort || 80,\n      });\n    } else {\n      throw new ValidationError('You must specify one of: taskDefinition or image', this);\n    }\n\n    const desiredCount = FeatureFlags.of(this).isEnabled(cxapi.ECS_REMOVE_DEFAULT_DESIRED_COUNT) ? this.internalDesiredCount : this.desiredCount;\n\n    this.service = new FargateService(this, 'Service', {\n      cluster: this.cluster,\n      desiredCount: desiredCount,\n      taskDefinition: this.taskDefinition,\n      assignPublicIp: this.assignPublicIp,\n      serviceName: props.serviceName,\n      healthCheckGracePeriod: props.healthCheckGracePeriod,\n      minHealthyPercent: props.minHealthyPercent,\n      maxHealthyPercent: props.maxHealthyPercent,\n      propagateTags: props.propagateTags,\n      enableECSManagedTags: props.enableECSManagedTags,\n      cloudMapOptions: props.cloudMapOptions,\n      platformVersion: props.platformVersion,\n      deploymentController: props.deploymentController,\n      circuitBreaker: props.circuitBreaker,\n      securityGroups: props.securityGroups,\n      vpcSubnets: props.taskSubnets,\n      enableExecuteCommand: props.enableExecuteCommand,\n      capacityProviderStrategies: props.capacityProviderStrategies,\n    });\n    this.addServiceAsTarget(this.service);\n  }\n}", "language": "typescript"}
{"input": "CDK class SnsToSqs for AWS resource management", "output": "class SnsToSqs extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    /// !show\n    const topic = new sns.Topic(this, 'MyTopic');\n    const queue = new sqs.Queue(this, 'MyQueue', {\n      encryptionMasterKey: new kms.Key(this, 'EncryptionMasterKey'),\n    });\n\n    topic.addSubscription(new subs.SqsSubscription(queue, {\n      deadLetterQueue: new sqs.Queue(this, 'DeadLetterQueue'),\n    }));\n    /// !hide\n  }\n}", "language": "typescript"}
{"input": "CDK class VirtualRouter for AWS resource management", "output": "export class VirtualRouter extends VirtualRouterBase {\n  /** Uniquely identifies this class. */\n  public static readonly PROPERTY_INJECTION_ID: string = 'aws-cdk-lib.aws-appmesh.VirtualRouter';\n\n  /**\n   * Import an existing VirtualRouter given an ARN\n   */\n  public static fromVirtualRouterArn(scope: Construct, id: string, virtualRouterArn: string): IVirtualRouter {\n    return new class extends VirtualRouterBase {\n      readonly virtualRouterArn = virtualRouterArn;\n      private readonly parsedArn = cdk.Fn.split('/', cdk.Stack.of(scope).splitArn(virtualRouterArn, cdk.ArnFormat.SLASH_RESOURCE_NAME).resourceName!);\n      readonly virtualRouterName = cdk.Fn.select(2, this.parsedArn);\n      readonly mesh = Mesh.fromMeshName(this, 'Mesh', cdk.Fn.select(0, this.parsedArn));\n    }(scope, id);\n  }\n\n  /**\n   * Import an existing VirtualRouter given attributes\n   */\n  public static fromVirtualRouterAttributes(scope: Construct, id: string, attrs: VirtualRouterAttributes): IVirtualRouter {\n    return new class extends VirtualRouterBase {\n      readonly virtualRouterName = attrs.virtualRouterName;\n      readonly mesh = attrs.mesh;\n      readonly virtualRouterArn = cdk.Stack.of(this).formatArn({\n        service: 'appmesh',\n        resource: `mesh/${attrs.mesh.meshName}/virtualRouter`,\n        resourceName: this.virtualRouterName,\n      });\n    }(scope, id);\n  }\n\n  /**\n   * The name of the VirtualRouter\n   */\n  public readonly virtualRouterName: string;\n\n  /**\n   * The Amazon Resource Name (ARN) for the VirtualRouter\n   */\n  public readonly virtualRouterArn: string;\n\n  /**\n   * The Mesh which the VirtualRouter belongs to\n   */\n  public readonly mesh: IMesh;\n\n  private readonly listeners = new Array<CfnVirtualRouter.VirtualRouterListenerProperty>();\n\n  constructor(scope: Construct, id: string, props: VirtualRouterProps) {\n    super(scope, id, {\n      physicalName: props.virtualRouterName || cdk.Lazy.string({ produce: () => cdk.Names.uniqueId(this) }),\n    });\n    // Enhanced CDK Analytics Telemetry\n    addConstructMetadata(this, props);\n\n    this.mesh = props.mesh;\n    if (props.listeners && props.listeners.length) {\n      props.listeners.forEach(listener => this.addListener(listener));\n    } else {\n      this.addListener(VirtualRouterListener.http());\n    }\n\n    const router = new CfnVirtualRouter(this, 'Resource', {\n      virtualRouterName: this.physicalName,\n      meshName: this.mesh.meshName,\n      meshOwner: renderMeshOwner(this.env.account, this.mesh.env.account),\n      spec: {\n        listeners: this.listeners,\n      },\n    });\n\n    this.virtualRouterName = this.getResourceNameAttribute(router.attrVirtualRouterName);\n    this.virtualRouterArn = this.getResourceArnAttribute(router.ref, {\n      service: 'appmesh',\n      resource: `mesh/${props.mesh.meshName}/virtualRouter`,\n      resourceName: this.physicalName,\n    });\n  }\n\n  /**\n   * Add port mappings to the router\n   */\n  private addListener(listener: VirtualRouterListener) {\n    this.listeners.push(listener.bind(this).listener);\n  }\n}", "language": "typescript"}
{"input": "CDK class TimerDurationImpl for AWS resource management", "output": "class TimerDurationImpl extends TimerDuration {\n  constructor(private readonly durationExpression: string) {\n    super();\n  }\n\n  public _bind() {\n    return this.durationExpression;\n  }\n}", "language": "typescript"}
{"input": "Represents a function schema for a Bedrock Agent Action Group", "output": "export class FunctionSchema extends ActionGroupSchema {\n  /**\n   * The functions defined in the schema\n   */\n  public readonly functions: Function[];\n\n  constructor(props: FunctionSchemaProps) {\n    super();\n\n    if (!props.functions || props.functions.length === 0) {\n      throw new validation.ValidationError('At least one function must be defined in the function schema');\n    }\n\n    this.functions = props.functions.map(f => new Function(f));\n  }\n\n  /**\n   * Render the function schema as a CloudFormation property\n   * @internal\n   */\n  public _render(): CfnAgent.FunctionSchemaProperty {\n    return {\n      functions: this.functions.map(f => f._render()),\n    };\n  }\n}", "language": "typescript"}
{"input": "Stack2 consumes the VPC", "output": "class Stack2 extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props: Stack2Props) {\n    super(scope, id, props);\n\n    this.node.setContext(EC2_RESTRICT_DEFAULT_SECURITY_GROUP, false);\n    // Pass the VPC to a construct that needs it\n    new ConstructThatTakesAVpc(this, 'Construct', {\n      vpc: props.vpc,\n    });\n  }\n}", "language": "typescript"}
{"input": "Helper class for working with Amazon-managed images", "output": "export class AmazonManagedImage {\n  /**\n   * Imports the Amazon Linux 2 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/linux/al2/ug/index.html\n   * @see https://gallery.ecr.aws/amazonlinux/amazonlinux\n   */\n  public static amazonLinux2(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.AMAZON_LINUX_2_CONFIG);\n  }\n\n  /**\n   * Imports the Amazon Linux 2023 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/linux/al2023/ug/what-is-amazon-linux.html\n   * @see https://gallery.ecr.aws/amazonlinux/amazonlinux\n   */\n  public static amazonLinux2023(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.AMAZON_LINUX_2023_CONFIG);\n  }\n\n  /**\n   * Imports the Red Hat Enterprise Linux 10 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://aws.amazon.com/partners/redhat/faqs\n   */\n  public static redHatEnterpriseLinux10(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.RED_HAT_ENTERPRISE_LINUX_10_CONFIG);\n  }\n\n  /**\n   * Imports the SUSE Linux Enterprise Server 15 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://aws.amazon.com/linux/commercial-linux/faqs/\n   */\n  public static suseLinuxEnterpriseServer15(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.SUSE_LINUX_ENTERPRISE_SERVER_15_CONFIG);\n  }\n\n  /**\n   * Imports the Ubuntu 22.04 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://documentation.ubuntu.com/aws\n   * @see https://hub.docker.com/_/ubuntu\n   */\n  public static ubuntuServer2204(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.UBUNTU_SERVER_22_04_CONFIG);\n  }\n\n  /**\n   * Imports the Ubuntu 24.04 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://documentation.ubuntu.com/aws\n   * @see https://hub.docker.com/_/ubuntu\n   */\n  public static ubuntuServer2404(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.UBUNTU_SERVER_24_04_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2016 Core Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   * @see https://hub.docker.com/r/microsoft/windows-servercore\n   */\n  public static windowsServer2016Core(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2016_CORE_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2016 Full Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   */\n  public static windowsServer2016Full(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2016_FULL_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2019 Core Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   * @see https://hub.docker.com/r/microsoft/windows-servercore\n   */\n  public static windowsServer2019Core(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2019_CORE_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2019 Full Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   */\n  public static windowsServer2019Full(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2019_FULL_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2022 Core Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   */\n  public static windowsServer2022Core(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2022_CORE_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2022 Full Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   */\n  public static windowsServer2022Full(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2022_FULL_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2025 Core Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   */\n  public static windowsServer2025Core(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2025_CORE_CONFIG);\n  }\n\n  /**\n   * Imports the Windows Server 2025 Full Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/ec2/latest/windows-ami-reference/index.html\n   */\n  public static windowsServer2025Full(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.WINDOWS_SERVER_2025_FULL_CONFIG);\n  }\n\n  /**\n   * Imports the macOS 14 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-mac-instances.html\n   */\n  public static macOS14(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.MACOS_14_CONFIG);\n  }\n\n  /**\n   * Imports the macOS 15 Amazon-managed image\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param opts The Amazon-managed image attributes\n   *\n   * @see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-mac-instances.html\n   */\n  public static macOS15(scope: Construct, id: string, opts: AmazonManagedImageOptions): IImage {\n    return this.predefinedManagedImage(scope, id, opts, this.MACOS_15_CONFIG);\n  }\n\n  /**\n   * Imports an Amazon-managed image from its attributes\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param attrs - The Amazon-managed image attributes\n   */\n  public static fromAmazonManagedImageAttributes(\n    scope: Construct,\n    id: string,\n    attrs: AmazonManagedImageAttributes,\n  ): IImage {\n    return Image.fromImageArn(\n      scope,\n      id,\n      cdk.Stack.of(scope).formatArn({\n        service: 'imagebuilder',\n        account: 'aws',\n        resource: 'image',\n        resourceName: `${attrs.imageName}/${attrs.imageVersion ?? LATEST_VERSION}`,\n      }),\n    );\n  }\n\n  /**\n   * Imports an Amazon-managed image from its name\n   *\n   * @param scope The construct scope\n   * @param id Identifier of the construct\n   * @param amazonManagedImageName - The name of the Amazon-managed image\n   */\n  public static fromAmazonManagedImageName(scope: Construct, id: string, amazonManagedImageName: string): IImage {\n    return this.fromAmazonManagedImageAttributes(scope, id, { imageName: amazonManagedImageName });\n  }\n\n  private static readonly AMAZON_LINUX_2_CONFIG: AmazonManagedImageConfig = {\n    image: 'Amazon Linux 2',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'amazon-linux-2-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'amazon-linux-2-arm64',\n      [`${ImageType.DOCKER}-${ImageArchitecture.X86_64}`]: 'amazon-linux-x86-2',\n    },\n  };\n\n  private static readonly AMAZON_LINUX_2023_CONFIG: AmazonManagedImageConfig = {\n    image: 'Amazon Linux 2023',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'amazon-linux-2023-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'amazon-linux-2023-arm64',\n      [`${ImageType.DOCKER}-${ImageArchitecture.X86_64}`]: 'amazon-linux-2023-x86-2023',\n    },\n  };\n\n  private static readonly RED_HAT_ENTERPRISE_LINUX_10_CONFIG: AmazonManagedImageConfig = {\n    image: 'Red Hat Enterprise Linux 10',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'red-hat-enterprise-linux-10-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'red-hat-enterprise-linux-10-arm64',\n    },\n  };\n\n  private static readonly SUSE_LINUX_ENTERPRISE_SERVER_15_CONFIG: AmazonManagedImageConfig = {\n    image: 'SUSE Linux Enterprise Server 15',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'suse-linux-enterprise-server-15-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'suse-linux-enterprise-server-15-arm64',\n    },\n  };\n\n  private static readonly UBUNTU_SERVER_22_04_CONFIG: AmazonManagedImageConfig = {\n    image: 'Ubuntu 22.04',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'ubuntu-server-22-lts-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'ubuntu-server-22-lts-arm64',\n      [`${ImageType.DOCKER}-${ImageArchitecture.X86_64}`]: 'ubuntu-22-x86-22-04',\n    },\n  };\n\n  private static readonly UBUNTU_SERVER_24_04_CONFIG: AmazonManagedImageConfig = {\n    image: 'Ubuntu 24.04',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'ubuntu-server-24-lts-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'ubuntu-server-24-lts-arm64',\n      [`${ImageType.DOCKER}-${ImageArchitecture.X86_64}`]: 'ubuntu-24-x86-24-04',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2016_CORE_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2016 Core',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2016-english-core-base-x86',\n      [`${ImageType.DOCKER}-${ImageArchitecture.X86_64}`]: 'windows-server-2016-x86-core-ltsc2016-amd64',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2016_FULL_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2016 Full',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2016-english-full-base-x86',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2019_CORE_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2019 Core',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2019-english-core-base-x86',\n      [`${ImageType.DOCKER}-${ImageArchitecture.X86_64}`]: 'windows-server-2019-x86-core-ltsc2019-amd64',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2019_FULL_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2019 Full',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2019-english-full-base-x86',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2022_CORE_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2022 Core',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2022-english-core-base-x86',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2022_FULL_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2022 Full',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2022-english-full-base-x86',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2025_CORE_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2025 Core',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2025-english-core-base-x86',\n    },\n  };\n\n  private static readonly WINDOWS_SERVER_2025_FULL_CONFIG: AmazonManagedImageConfig = {\n    image: 'Windows Server 2025 Full',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'windows-server-2025-english-full-base-x86',\n    },\n  };\n\n  private static readonly MACOS_14_CONFIG: AmazonManagedImageConfig = {\n    image: 'macOS 14',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'macos-sonoma-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'macos-sonoma-arm64',\n    },\n  };\n\n  private static readonly MACOS_15_CONFIG: AmazonManagedImageConfig = {\n    image: 'macOS 15',\n    supportedCombinations: {\n      [`${ImageType.AMI}-${ImageArchitecture.X86_64}`]: 'macos-sequoia-x86',\n      [`${ImageType.AMI}-${ImageArchitecture.ARM64}`]: 'macos-sequoia-arm64',\n    },\n  };\n\n  private static validatePredefinedManagedImageOptions(\n    scope: Construct,\n    opts: AmazonManagedImageOptions,\n    image: string,\n  ) {\n    if (cdk.Token.isUnresolved(opts.imageArchitecture)) {\n      throw new cdk.ValidationError(`architecture cannot be a token for ${image}`, scope);\n    }\n\n    if (cdk.Token.isUnresolved(opts.imageType)) {\n      throw new cdk.ValidationError(`type cannot be a token for ${image}`, scope);\n    }\n  }\n\n  private static predefinedManagedImage(\n    scope: Construct,\n    id: string,\n    opts: AmazonManagedImageOptions,\n    config: AmazonManagedImageConfig,\n  ): IImage {\n    this.validatePredefinedManagedImageOptions(scope, opts, config.image);\n\n    const key = `${opts.imageType}-${opts.imageArchitecture}`;\n    const imageName = config.supportedCombinations[key];\n\n    if (!imageName) {\n      throw new cdk.ValidationError(\n        `architecture ${opts.imageArchitecture} with type ${opts.imageType} is not a supported architecture and type for ${config.image}`,\n        scope,\n      );\n    }\n\n    return this.fromAmazonManagedImageAttributes(scope, id, {\n      imageName,\n      imageVersion: opts.imageVersion,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class GlobalDDBTableCMK for AWS resource management", "output": "class GlobalDDBTableCMK(cdk.Stack):\n    def __init__(\n        self,\n        scope: Construct,\n        id: str,\n        table_name: str,\n        replication_regions: List[str],\n        key_alias: str = None,\n        **kwargs\n    ) -> None:\n        super().__init__(scope, id, **kwargs)\n\n        cmk_stack = CMKStack(\n            self,\n            \"cmk-stack\",\n            table_name=table_name,\n            key_replica_regions=replication_regions,\n            key_alias=key_alias,\n        )\n\n        ddb_stack = DynamoDBStack(\n            self,\n            \"ddb-stack\",\n            table_name=table_name,\n            table_replica_regions=[\n                {\n                    \"region\": region,\n                    \"key_export_name\": cmk_stack.get_key_replica_export_names(region),\n                }\n                for region in [self.region, *replication_regions]\n            ],\n        )\n        ddb_stack.add_dependency(cmk_stack)", "language": "python"}
{"input": "Test for importing an existing table", "output": "class ImportedTableStack extends core.Stack {\n  public readonly importedTable: s3tables.ITable;\n  public readonly createdTable: s3tables.Table;\n  public readonly namespace: s3tables.Namespace;\n  public readonly tableBucket: s3tables.TableBucket;\n\n  constructor(scope: Construct, id: string, props?: core.StackProps) {\n    super(scope, id, props);\n\n    this.tableBucket = new s3tables.TableBucket(this, 'ImportBucket', {\n      tableBucketName: 'import-table-bucket',\n      removalPolicy: core.RemovalPolicy.DESTROY,\n    });\n\n    this.namespace = new s3tables.Namespace(this, 'ImportNamespace', {\n      namespaceName: 'import_table_namespace',\n      tableBucket: this.tableBucket,\n      removalPolicy: core.RemovalPolicy.DESTROY,\n    });\n\n    // Create a table to import\n    this.createdTable = new s3tables.Table(this, 'CreatedTable', {\n      tableName: 'import_test_table',\n      namespace: this.namespace,\n      openTableFormat: s3tables.OpenTableFormat.ICEBERG,\n      withoutMetadata: true,\n      removalPolicy: core.RemovalPolicy.DESTROY,\n    });\n\n    // Import the table using fromTableAttributes\n    this.importedTable = s3tables.Table.fromTableAttributes(this, 'ImportedTable', {\n      tableName: this.createdTable.tableName,\n      tableArn: this.createdTable.tableArn,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK Construct for IAM, ECS, SageMaker infrastructure components", "output": "class ConstructCreatingContainerImage extends sagemaker.ContainerImage {\n      public bind(scope: constructs.Construct, _model: sagemaker.Model): sagemaker.ContainerImageConfig {\n        new iam.User(scope, 'User', {\n          userName: 'ExtraConstructUserName',\n        });\n        return {\n          imageName: 'anything',\n        };\n      }\n    }", "language": "typescript"}
{"input": "CDK class DashboardWithGraphWidgetWithLabelsVisibleIntegrationTest for AWS resource management", "output": "class DashboardWithGraphWidgetWithLabelsVisibleIntegrationTest extends Stack {\n  constructor(scope: App, id: string, props?: StackProps) {\n    super(scope, id, props);\n    const dashboard = new Dashboard(this, 'Dash');\n    const metrics = [\n      new Metric({\n        namespace: 'CDK/Test',\n        metricName: 'Metric',\n        label: 'Metric left 1 - p99',\n        statistic: Stats.p(99),\n      }),\n\n      new Metric({\n        namespace: 'CDK/Test',\n        metricName: 'Metric',\n        label: 'Metric left 2 - TC_10P_90P',\n        statistic: Stats.tc(10, 90),\n      }),\n\n      new Metric({\n        namespace: 'CDK/Test',\n        metricName: 'Metric',\n        label: 'Metric left 3 - TS(5%:95%)',\n        statistic: 'TS(5%:95%)',\n      }),\n    ];\n\n    const widgetProps: GraphWidgetProps = {\n      title: 'My fancy graph',\n      left: metrics,\n      right: [],\n      view: GraphWidgetView.PIE,\n      leftAnnotations: [\n        {\n          value: 10,\n          label: 'Left annotation',\n          color: '#00ff00',\n          fill: Shading.ABOVE,\n          visible: true,\n        },\n      ],\n      rightAnnotations: [\n        {\n          value: 20,\n          label: 'Right annotation',\n          color: '#e30d0d',\n          fill: Shading.BELOW,\n          visible: false,\n        },\n      ],\n      verticalAnnotations: [\n        {\n          date: '2023-08-20T00:00:00.000Z',\n          label: 'Vertical annotation',\n          color: '#2556f6',\n          fill: VerticalShading.AFTER,\n          visible: true,\n        },\n      ],\n    };\n\n    dashboard.addWidgets(\n      new GraphWidget({\n        ...widgetProps,\n        displayLabelsOnChart: true,\n      }),\n      new GraphWidget({\n        ...widgetProps,\n        displayLabelsOnChart: false,\n      }),\n      new GraphWidget(widgetProps),\n    );\n  }\n}", "language": "typescript"}
{"input": "CDK class Pinger for AWS resource management", "output": "export class Pinger extends Construct {\n  private _resource: CustomResource;\n\n  constructor(scope: Construct, id: string, props: PingerProps) {\n    super(scope, id);\n\n    const func = new lambda.Function(this, 'Function', {\n      code: lambda.Code.fromAsset(path.join(__dirname, 'function')),\n      handler: 'index.handler',\n      runtime: lambda.Runtime.PYTHON_3_9,\n      vpc: props.vpc,\n      vpcSubnets: props.subnets ? { subnets: props.subnets } : undefined,\n      securityGroups: props.securityGroup ? [props.securityGroup] : undefined,\n      timeout: Duration.minutes(10),\n    });\n\n    const provider = new cr.Provider(this, 'Provider', {\n      onEventHandler: func,\n    });\n\n    this._resource = new CustomResource(this, 'Resource', {\n      serviceToken: provider.serviceToken,\n      properties: {\n        Url: props.url,\n      },\n    });\n  }\n\n  public get response() {\n    return Token.asString(this._resource.getAtt('Value'));\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates MSK (Kafka), CloudFormation, ECS, EKS resources", "output": "export class OsVpcProvisionStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    this.templateOptions.templateFormatVersion = '2010-09-09';\n\n    const commonResources = new CommonResources(this, 'CommonResources', {});\n\n\n    const osCluster = new OSCluster(this, \"OSCluster\", {\n      vpc: commonResources.vpc,\n      userPool: commonResources.cognitoUserPool,\n      identityPool: commonResources.cognitoIdentityPool,\n      identityPoolPolicy: commonResources.cognitoIdentityPoolPolicy,\n      cognitoEndpoint: commonResources.cognitoEndpoint,\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK helper function get_key_replica_export_names", "output": "def get_key_replica_export_names(self, region: str):\n        return f\"{self._key_arn_export_prefix}{region}\"", "language": "python"}
{"input": "CDK class ECSCluster for AWS resource management", "output": "class ECSCluster(Stack):\n\n    def __init__(self, scope: Construct, id: str, **kwargs) -> None:\n        super().__init__(scope, id, *kwargs)\n\n        vpc = ec2.Vpc(\n            self, \"MyVpc\",\n            max_azs=2\n        )\n\n        asg = autoscaling.AutoScalingGroup(\n            self, \"MyFleet\",\n            instance_type=ec2.InstanceType(\"t2.xlarge\"),\n            machine_image=ecs.EcsOptimizedImage.amazon_linux2(),\n            associate_public_ip_address=True,\n            desired_capacity=3,\n            vpc=vpc,\n            vpc_subnets=ec2.SubnetSelection(subnet_type=ec2.SubnetType.PUBLIC),\n        )\n\n        cluster = ecs.Cluster(\n            self, 'EcsCluster',\n            vpc=vpc\n        )\n\n        capacity_provider = ecs.AsgCapacityProvider(self, \"AsgCapacityProvider\",\n            auto_scaling_group=asg\n        )\n        cluster.add_asg_capacity_provider(capacity_provider)", "language": "python"}
{"input": "CDK class VirtualServiceProviderImpl for AWS resource management", "output": "class VirtualServiceProviderImpl extends VirtualServiceProvider {\n  private readonly virtualNode?: IVirtualNode;\n  private readonly virtualRouter?: IVirtualRouter;\n  private readonly mesh: IMesh;\n\n  constructor(virtualNode?: IVirtualNode, virtualRouter?: IVirtualRouter, mesh?: IMesh) {\n    super();\n    this.virtualNode = virtualNode;\n    this.virtualRouter = virtualRouter;\n    const providedMesh = this.virtualNode?.mesh ?? this.virtualRouter?.mesh ?? mesh!;\n    this.mesh = providedMesh;\n  }\n\n  public bind(_construct: Construct): VirtualServiceProviderConfig {\n    return {\n      mesh: this.mesh,\n      virtualNodeProvider: this.virtualNode\n        ? {\n          virtualNodeName: this.virtualNode.virtualNodeName,\n        }\n        : undefined,\n      virtualRouterProvider: this.virtualRouter\n        ? {\n          virtualRouterName: this.virtualRouter.virtualRouterName,\n        }\n        : undefined,\n    };\n  }\n}", "language": "typescript"}
{"input": "CDK class KafkaVersionTest for AWS resource management", "output": "class KafkaVersionTest extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n    const vpc = new Vpc(this, 'Vpc', { maxAzs: 2, restrictDefaultSecurityGroup: false });\n\n    versions.forEach(version => {\n      const versionName = version.version.replace(/\\./g, '-');\n      new msk.Cluster(this, `ClusterVersion${versionName}`, {\n        clusterName: `cluster-v${versionName}`,\n        kafkaVersion: version,\n        vpc,\n        removalPolicy: RemovalPolicy.DESTROY,\n      });\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class VPCResources for AWS resource management", "output": "export class VPCResources extends Construct {\n  public sshSecurityGroup: SecurityGroup;\n  public vpc: Vpc;\n\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    // Create a VPC with public subnets in 2 AZs\n    this.vpc = new Vpc(this, 'VPC', {\n      natGateways: 0,\n      subnetConfiguration: [\n        {\n          cidrMask: 24,\n          name: 'ServerPublic',\n          subnetType: SubnetType.PUBLIC,\n          mapPublicIpOnLaunch: true,\n        },\n      ],\n      maxAzs: 2,\n    });\n\n    // Create a security group for SSH\n    this.sshSecurityGroup = new SecurityGroup(this, 'SSHSecurityGroup', {\n      vpc: this.vpc,\n      description: 'Security Group for SSH',\n      allowAllOutbound: true,\n    });\n\n    // Allow SSH inbound traffic on TCP port 22\n    this.sshSecurityGroup.addIngressRule(Peer.anyIpv4(), Port.tcp(22));\n  }\n}", "language": "typescript"}
{"input": "CDK class EventBridgeBuilder for AWS resource management", "output": "export class EventBridgeBuilder extends LibraryBuilder<EventBridgeServiceModule> {\n  private readonly filePattern: string;\n\n  public constructor(props: EventBridgeBuilderProps) {\n    super(props);\n    this.filePattern = props.filePattern ?? '%moduleName%/events.generated.ts';\n  }\n\n  protected createServiceSubmodule(service: Service, submoduleName: string): EventBridgeServiceModule {\n    return new EventBridgeServiceModule({\n      submoduleName,\n      service,\n    });\n  }\n\n  protected addResourceToSubmodule(submodule: EventBridgeServiceModule, resource: Resource, _props?: AddServiceProps): void {\n    const events = this.db.follow('resourceHasEvent', resource).map((e) => e.entity);\n    if (events.length === 0) {\n      return;\n    }\n\n    const service = this.db.incoming('hasResource', resource).only().entity;\n\n    // Create a temporary module to test if events can be generated\n    const tempModuleName = `@aws-cdk/mixins-preview/${submodule.submoduleName}/events-temp`;\n    const tempModule = new Module(tempModuleName);\n    CDK_CORE.import(tempModule, 'cdk');\n    submodule.constructLibModule.import(tempModule, 'service');\n    const awsEvents = new ExternalModule('aws-cdk-lib/aws-events');\n    awsEvents.import(tempModule, 'events');\n\n    const eventsClass = new EventBridgeEventsClass(tempModule, this.db, resource, events, submodule.constructLibModule);\n    eventsClass.build();\n\n    // Only create the real module and register if we successfully generated at least one event\n    if (eventsClass.hasSuccessfulEvents()) {\n      const eventsModule = this.obtainEventsModule(submodule, service);\n\n      // Recreate the class in the real module\n      const realEventsClass = new EventBridgeEventsClass(eventsModule.module, this.db, resource, events, submodule.constructLibModule);\n      realEventsClass.build();\n\n      submodule.registerResource(resource.cloudFormationType, realEventsClass);\n    }\n  }\n\n  private createEventsModule(submodule: EventBridgeServiceModule, service: Service): LocatedModule<Module> {\n    const module = new Module(`@aws-cdk/mixins-preview/${submodule.submoduleName}/events`);\n    const filePath = this.pathFor(this.filePattern, submodule.submoduleName, service);\n\n    submodule.registerModule({ module, filePath });\n\n    CDK_CORE.import(module, 'cdk');\n    submodule.constructLibModule.import(module, 'service');\n\n    const awsEvents = new ExternalModule('aws-cdk-lib/aws-events');\n    awsEvents.import(module, 'events');\n\n    return { module, filePath };\n  }\n\n  private obtainEventsModule(submodule: EventBridgeServiceModule, service: Service): LocatedModule<Module> {\n    const mod = this.createEventsModule(submodule, service);\n    if (this.modules.has(mod.filePath)) {\n      return {\n        module: this.modules.get(mod.filePath)!,\n        filePath: mod.filePath,\n      };\n    }\n\n    return this.rememberModule(mod);\n  }\n}", "language": "typescript"}
{"input": "CDK class WillkommenFargate for AWS resource management", "output": "class WillkommenFargate extends cdk.Stack {\n  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const vpc = new ec2.Vpc(this, 'MyVpc', { maxAzs: 2 });\n    const cluster = new ecs.Cluster(this, 'Ec2Cluster', { vpc });\n\n    // create a task definition with CloudWatch Logs\n    const logging = new ecs.AwsLogDriver({\n      streamPrefix: \"myapp\",\n    })\n\n    const taskDef = new ecs.FargateTaskDefinition(this, \"MyTaskDefinition\", {\n      memoryLimitMiB: 512,\n      cpu: 256,\n    })\n    \n    taskDef.addContainer(\"AppContainer\", {\n      image: ecs.ContainerImage.fromRegistry(\"amazon/amazon-ecs-sample\"),\n      logging,\n    })\n\n    // Instantiate ECS Service with just cluster and image\n    new ecs.FargateService(this, \"FargateService\", {\n      cluster,\n      taskDefinition: taskDef\n    });\n  }\n}", "language": "typescript"}
{"input": "JSII Java package is required and must look sane", "output": "export class JSIIJavaPackageIsRequired extends ValidationRule {\n  public readonly name = 'jsii/java';\n\n  public validate(pkg: PackageJson): void {\n    if (!isJSII(pkg)) { return; }\n\n    const moduleName = cdkModuleName(pkg.json.name);\n\n    expectJSON(this.name, pkg, 'jsii.targets.java.maven.groupId', 'software.amazon.awscdk');\n    expectJSON(this.name, pkg, 'jsii.targets.java.maven.artifactId', moduleName.mavenArtifactId, /-/g);\n\n    const java = deepGet(pkg.json, ['jsii', 'targets', 'java', 'package']) as string | undefined;\n    expectJSON(this.name, pkg, 'jsii.targets.java.package', moduleName.javaPackage, /\\./g);\n    if (java) {\n      const expectedPrefix = moduleName.javaPackage.split('.').slice(0, 3).join('.');\n      const actualPrefix = java.split('.').slice(0, 3).join('.');\n      if (expectedPrefix !== actualPrefix) {\n        pkg.report({\n          ruleName: this.name,\n          message: `JSII \"java\" package must share the first 3 elements of the expected one: ${expectedPrefix} vs ${actualPrefix}`,\n          fix: () => deepSet(pkg.json, ['jsii', 'targets', 'java', 'package'], moduleName.javaPackage),\n        });\n      }\n    }\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates CloudFormation, CDK Pipelines, CodePipeline, ECR resources", "output": "class PipelineStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const repository = new ecr.Repository(this, 'Source', { removalPolicy: RemovalPolicy.DESTROY });\n\n    const pipeline = new pipelines.CodePipeline(this, 'Pipeline', {\n      synth: new pipelines.ShellStep('Synth', {\n        input: pipelines.CodePipelineSource.ecr(repository),\n        commands: ['mkdir cdk.out', 'touch cdk.out/dummy'],\n      }),\n      selfMutation: false,\n    });\n    const stage = new AppStage(this, 'AppStage');\n\n    const postStep = new CustomStep(stage.output);\n\n    // WHEN\n\n    pipeline.addStage(stage, { post: [postStep] });\n  }\n}", "language": "typescript"}
{"input": "CDK Stack that creates Lambda, CloudWatch Logs, CloudFormation resources", "output": "class SubscriptionFilterIntegStack extends Stack {\n  constructor(scope: App, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const logGroup = new LogGroup(this, 'LogGroup');\n\n    const fn = new Function(this, 'Function', {\n      runtime: Runtime.NODEJS_20_X,\n      handler: 'index.handler',\n      code: Code.fromInline('foo'),\n    });\n\n    logGroup.addSubscriptionFilter('Subscription', {\n      destination: new LambdaDestination(fn),\n      filterPattern: FilterPattern.allTerms('ERROR', 'MainThread'),\n      filterName: 'CustomSubscriptionFilterName',\n    });\n  }\n}", "language": "typescript"}
{"input": "CDK class SNSFifoInteg for AWS resource management", "output": "class SNSFifoInteg extends Stack {\n  constructor(scope: App, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    new Topic(this, 'MyTopic', {\n      topicName: 'fooTopic',\n      displayName: 'fooDisplayName',\n      contentBasedDeduplication: true,\n      fifo: true,\n    });\n  }\n}", "language": "typescript"}
{"input": "Test for CloudFormation Outputs\n  - Upload File To S3 Instructions\n  - Queue Url\n  - Lambda Function Name\n  - Lambda Function Log Group Name", "output": "def test_outputs_created(template):\n    \"\"\"\n    Test for CloudFormation Outputs\n      - Upload File To S3 Instructions\n      - Queue Url\n      - Lambda Function Name\n      - Lambda Function Log Group Name\n    \"\"\"\n    template.has\n    template.has_output(\"UploadFileToS3Example\", {})\n    template.has_output(\"UploadSqsQueueUrl\", {})\n    template.has_output(\"LambdaFunctionName\", {})\n    template.has_output(\"LambdaFunctionLogGroupName\", {})", "language": "python"}
{"input": "CDK Stack that creates S3, Lambda, DynamoDB, AppSync resources", "output": "export class CdkAppsyncDemoStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // Create DynamoDB tables\n    const carsTable = new Table(this, 'CarTable', {\n      partitionKey: { name: 'licenseplate', type: AttributeType.STRING },\n      tableName: 'cardata-cars',\n      removalPolicy: cdk.RemovalPolicy.DESTROY,\n      billingMode: BillingMode.PROVISIONED,\n      readCapacity: 2,\n      writeCapacity: 4\n    });\n\n    const defectsTable = new Table(this, 'DefectsTable', {\n      partitionKey: { name: 'id', type: AttributeType.STRING },\n      removalPolicy: cdk.RemovalPolicy.DESTROY,\n      tableName: 'cardata-defects',\n      billingMode: BillingMode.PROVISIONED,\n      readCapacity: 2,\n      writeCapacity: 4\n    });\n\n    defectsTable.addGlobalSecondaryIndex({\n      indexName: 'defect-by-licenseplate',\n      partitionKey: {\n        name: 'licenseplate',\n        type: AttributeType.STRING\n      },\n      readCapacity: 2,\n      writeCapacity: 4,\n    })\n\n    const api = new GraphqlApi(this, 'CarApi', {\n      name: 'carAPI',\n      definition: Definition.fromFile(path.join(__dirname, '../graphql/schema.graphql')),\n      authorizationConfig: {\n        defaultAuthorization: {\n          authorizationType: AuthorizationType.IAM,\n        },\n      },\n      xrayEnabled: true,\n    });\n\n    // Connect DynamoDB tables to the AppSync API as data sources\n    const carsDataSource = api.addDynamoDbDataSource('CarsDataSource', carsTable);\n    const defectsDataSource = api.addDynamoDbDataSource('DefectsDataSource', defectsTable);\n\n    const carsResolver = new AppsyncFunction(this, 'CarsFunction', {\n      name: 'getCars',\n      api,\n      dataSource: carsDataSource,\n      code: Code.fromAsset(path.join(__dirname, '../resolvers/getCar.js')),\n      runtime: FunctionRuntime.JS_1_0_0,\n    });\n\n    const defectsResolver = new AppsyncFunction(this, 'DefectsFunction', {\n      name: 'getDefects',\n      api,\n      dataSource: defectsDataSource,\n      code: Code.fromAsset(path.join(__dirname, '../resolvers/getDefects.js')),\n      runtime: FunctionRuntime.JS_1_0_0,\n    });\n\n    new Resolver(this, 'PipelineResolverGetCars', {\n      api,\n      typeName: 'Query',\n      fieldName: 'getCar',\n      runtime: FunctionRuntime.JS_1_0_0,\n      code: Code.fromAsset(path.join(__dirname, '../resolvers/pipeline.js')),\n      pipelineConfig: [carsResolver],\n    });\n\n    new Resolver(this, 'PipelineResolverGetDefects', {\n      api,\n      typeName: 'Car',\n      fieldName: 'defects',\n      runtime: FunctionRuntime.JS_1_0_0,\n      code: Code.fromAsset(path.join(__dirname, '../resolvers/pipeline.js')),\n      pipelineConfig: [defectsResolver],\n    });\n\n  }\n}", "language": "typescript"}
{"input": "CDK class CustomResourceProvider for AWS resource management", "output": "class CustomResourceProvider extends HandlerFrameworkClass {\n      public constructor() {\n        super(scope, {\n          name: props.name,\n          extends: CORE_MODULE.CustomResourceProviderBase,\n          export: true,\n        });\n\n        if (scope.isCoreInternal) {\n          scope.registerImport(CORE_MODULE, {\n            targets: [CORE_MODULE.Stack],\n            fromLocation: CORE_INTERNAL_STACK_IMPORT_PATH,\n          });\n          scope.registerImport(CORE_MODULE, {\n            targets: [\n              CORE_MODULE.CustomResourceProviderBase,\n              CORE_MODULE.CustomResourceProviderOptions,\n            ],\n            fromLocation: CORE_INTERNAL_CUSTOM_RESOURCE_PROVIDER_IMPORT_PATH,\n          });\n        } else {\n          scope.registerImport(CORE_MODULE, {\n            targets: [\n              CORE_MODULE.Stack,\n              CORE_MODULE.CustomResourceProviderBase,\n              CORE_MODULE.CustomResourceProviderOptions,\n            ],\n          });\n        }\n\n        const getOrCreateMethod = this.addMethod({\n          name: 'getOrCreate',\n          static: true,\n          returnType: Type.STRING,\n          docs: {\n            summary: 'Returns a stack-level singleton ARN (service token) for the custom resource provider.',\n          },\n        });\n        getOrCreateMethod.addParameter({\n          name: 'scope',\n          type: CONSTRUCTS_MODULE.Construct,\n        });\n        getOrCreateMethod.addParameter({\n          name: 'uniqueid',\n          type: Type.STRING,\n        });\n        getOrCreateMethod.addParameter({\n          name: 'props',\n          type: CORE_MODULE.CustomResourceProviderOptions,\n          optional: true,\n        });\n        getOrCreateMethod.addBody(\n          stmt.ret(expr.directCode('this.getOrCreateProvider(scope, uniqueid, props).serviceToken')),\n        );\n\n        const getOrCreateProviderMethod = this.addMethod({\n          name: 'getOrCreateProvider',\n          static: true,\n          returnType: this.type,\n          docs: {\n            summary: 'Returns a stack-level singleton for the custom resource provider.',\n          },\n        });\n        const _scope = getOrCreateProviderMethod.addParameter({\n          name: 'scope',\n          type: CONSTRUCTS_MODULE.Construct,\n        });\n        getOrCreateProviderMethod.addParameter({\n          name: 'uniqueid',\n          type: Type.STRING,\n        });\n        getOrCreateProviderMethod.addParameter({\n          name: 'props',\n          type: CORE_MODULE.CustomResourceProviderOptions,\n          optional: true,\n        });\n        getOrCreateProviderMethod.addBody(\n          stmt.constVar(expr.ident('id'), expr.directCode('`${uniqueid}CustomResourceProvider`')),\n          stmt.constVar(expr.ident('stack'), $T(CORE_MODULE.Stack).of(expr.directCode(_scope.spec.name))),\n          stmt.constVar(expr.ident('existing'), expr.directCode(`stack.node.tryFindChild(id) as ${this.type}`)),\n          stmt.ret(expr.directCode(`existing ?? new ${this.name}(stack, id, props)`)),\n        );\n\n        const superProps = new ObjectLiteral([\n          new Splat(expr.ident('props')),\n          ['codeDirectory', PATH_MODULE.join.call(expr.directCode(`__dirname, '${props.codeDirectory}'`))],\n          ['runtimeName', this.buildRuntimeProperty(scope, {\n            runtime: props.runtime,\n            isCustomResourceProvider: true,\n          })],\n        ]);\n        const metadataStatements: Statement[] = [stmt.directCode(`this.node.addMetadata('${CUSTOM_RESOURCE_PROVIDER}', true)`)];\n        this.buildConstructor({\n          constructorPropsType: CORE_MODULE.CustomResourceProviderOptions,\n          superProps,\n          constructorVisibility: props.constructorVisibility ?? MemberVisibility.Private,\n          optionalConstructorProps: true,\n          statements: metadataStatements,\n        });\n      }\n    }", "language": "typescript"}
